<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MurmurHash3.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Codec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.codec.digest</a> &gt; <span class="el_source">MurmurHash3.java</span></div><h1>MurmurHash3.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.codec.digest;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

import org.apache.commons.codec.binary.StringUtils;

/**
 * Implementation of the MurmurHash3 32-bit and 128-bit hash functions.
 *
 * &lt;p&gt;
 * MurmurHash is a non-cryptographic hash function suitable for general hash-based lookup. The name comes from two basic
 * operations, multiply (MU) and rotate (R), used in its inner loop. Unlike cryptographic hash functions, it is not
 * specifically designed to be difficult to reverse by an adversary, making it unsuitable for cryptographic purposes.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * This contains a Java port of the 32-bit hash function {@code MurmurHash3_x86_32} and the 128-bit hash function
 * {@code MurmurHash3_x64_128} from Austin Applyby's original {@code c++} code in SMHasher.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * This is public domain code with no copyrights. From home page of
 * &lt;a href=&quot;https://github.com/aappleby/smhasher&quot;&gt;SMHasher&lt;/a&gt;:
 * &lt;/p&gt;
 *
 * &lt;blockquote&gt; &quot;All MurmurHash versions are public domain software, and the author disclaims all copyright to their
 * code.&quot; &lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * Original adaption from Apache Hive. That adaption contains a {@code hash64} method that is not part of the original
 * MurmurHash3 code. It is not recommended to use these methods. They will be removed in a future release. To obtain a
 * 64-bit hash use half of the bits from the {@code hash128x64} methods using the input data converted to bytes.
 * &lt;p&gt;
 *
 * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/MurmurHash&quot;&gt;MurmurHash&lt;/a&gt;
 * @see &lt;a href=&quot;https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp&quot;&gt; Original MurmurHash3 c++
 *      code&lt;/a&gt;
 * @see &lt;a href=
 *      &quot;https://github.com/apache/hive/blob/master/storage-api/src/java/org/apache/hive/common/util/Murmur3.java&quot;&gt;
 *      Apache Hive Murmer3&lt;/a&gt;
 * @since 1.13
 */
public final class MurmurHash3 {

    /**
     * A random number to use for a hash code.
     *
     * @deprecated This is not used internally and will be removed in a future release.
     */
    @Deprecated
    public static final long NULL_HASHCODE = 2862933555777941757L;

    /**
     * A default seed to use for the murmur hash algorithm.
     * Has the value {@code 104729}.
     */
    public static final int DEFAULT_SEED = 104729;

    /** TODO Replace on Java 8 with Long.BYTES. */
    static final int LONG_BYTES = Long.SIZE / Byte.SIZE;

    /** TODO Replace on Java 8 with Integer.BYTES. */
    static final int INTEGER_BYTES = Integer.SIZE / Byte.SIZE;

    /** TODO Replace on Java 8 with Short.BYTES. */
    static final int SHORT_BYTES = Short.SIZE / Byte.SIZE;

    // Constants for 32-bit variant
    private static final int C1_32 = 0xcc9e2d51;
    private static final int C2_32 = 0x1b873593;
    private static final int R1_32 = 15;
    private static final int R2_32 = 13;
    private static final int M_32 = 5;
    private static final int N_32 = 0xe6546b64;

    // Constants for 128-bit variant
    private static final long C1 = 0x87c37b91114253d5L;
    private static final long C2 = 0x4cf5ad432745937fL;
    private static final int R1 = 31;
    private static final int R2 = 27;
    private static final int R3 = 33;
    private static final int M = 5;
    private static final int N1 = 0x52dce729;
    private static final int N2 = 0x38495ab5;

    /** No instance methods. */
    private MurmurHash3() {
    }

    /**
     * Generates 32-bit hash from two longs with a default seed value.
     * This is a helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 104729;
     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(16)
     *                                            .putLong(data1)
     *                                            .putLong(data2)
     *                                            .array(), offset, 16, seed);
     * &lt;/pre&gt;
     *
     * @param data1 The first long to hash
     * @param data2 The second long to hash
     * @return The 32-bit hash
     * @see #hash32x86(byte[], int, int, int)
     */
    public static int hash32(final long data1, final long data2) {
<span class="fc" id="L127">        return hash32(data1, data2, DEFAULT_SEED);</span>
    }

    /**
     * Generates 32-bit hash from two longs with the given seed.
     * This is a helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(16)
     *                                            .putLong(data1)
     *                                            .putLong(data2)
     *                                            .array(), offset, 16, seed);
     * &lt;/pre&gt;
     *
     * @param data1 The first long to hash
     * @param data2 The second long to hash
     * @param seed The initial seed value
     * @return The 32-bit hash
     * @see #hash32x86(byte[], int, int, int)
     */
    public static int hash32(final long data1, final long data2, final int seed) {
<span class="fc" id="L149">        int hash = seed;</span>
<span class="fc" id="L150">        final long r0 = Long.reverseBytes(data1);</span>
<span class="fc" id="L151">        final long r1 = Long.reverseBytes(data2);</span>

<span class="fc" id="L153">        hash = mix32((int) r0, hash);</span>
<span class="fc" id="L154">        hash = mix32((int) (r0 &gt;&gt;&gt; 32), hash);</span>
<span class="fc" id="L155">        hash = mix32((int) (r1), hash);</span>
<span class="fc" id="L156">        hash = mix32((int) (r1 &gt;&gt;&gt; 32), hash);</span>

<span class="fc" id="L158">        hash ^= LONG_BYTES * 2;</span>
<span class="fc" id="L159">        return fmix32(hash);</span>
    }

    /**
     * Generates 32-bit hash from a long with a default seed value.
     * This is a helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 104729;
     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(8)
     *                                            .putLong(data)
     *                                            .array(), offset, 8, seed);
     * &lt;/pre&gt;
     *
     * @param data The long to hash
     * @return The 32-bit hash
     * @see #hash32x86(byte[], int, int, int)
     */
    public static int hash32(final long data) {
<span class="fc" id="L179">        return hash32(data, DEFAULT_SEED);</span>
    }

    /**
     * Generates 32-bit hash from a long with the given seed.
     * This is a helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(8)
     *                                            .putLong(data)
     *                                            .array(), offset, 8, seed);
     * &lt;/pre&gt;
     *
     * @param data The long to hash
     * @param seed The initial seed value
     * @return The 32-bit hash
     * @see #hash32x86(byte[], int, int, int)
     */
    public static int hash32(final long data, final int seed) {
<span class="fc" id="L199">        int hash = seed;</span>
<span class="fc" id="L200">        final long r0 = Long.reverseBytes(data);</span>

<span class="fc" id="L202">        hash = mix32((int) r0, hash);</span>
<span class="fc" id="L203">        hash = mix32((int) (r0 &gt;&gt;&gt; 32), hash);</span>

<span class="fc" id="L205">        hash ^= LONG_BYTES;</span>
<span class="fc" id="L206">        return fmix32(hash);</span>
    }

    /**
     * Generates 32-bit hash from the byte array with a default seed.
     * This is a helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 104729;
     * int hash = MurmurHash3.hash32(data, offset, data.length, seed);
     * &lt;/pre&gt;
     *
     * &lt;p&gt;This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.&lt;p&gt;
     *
     * @param data The input byte array
     * @return The 32-bit hash
     * @see #hash32(byte[], int, int, int)
     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.
     */
    @Deprecated
    public static int hash32(final byte[] data) {
<span class="fc" id="L230">        return hash32(data, 0, data.length, DEFAULT_SEED);</span>
    }

    /**
     * Generates 32-bit hash from a string with a default seed.
     * &lt;p&gt;
     * Before 1.14 the string was converted using default encoding.
     * Since 1.14 the string is converted to bytes using UTF-8 encoding.
     * &lt;/p&gt;
     * This is a helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 104729;
     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);
     * int hash = MurmurHash3.hash32(bytes, offset, bytes.length, seed);
     * &lt;/pre&gt;
     *
     * &lt;p&gt;This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.&lt;p&gt;
     *
     * @param data The input string
     * @return The 32-bit hash
     * @see #hash32(byte[], int, int, int)
     * @deprecated Use {@link #hash32x86(byte[], int, int, int)} with the bytes returned from
     * {@link String#getBytes(java.nio.charset.Charset)}. This corrects the processing of trailing bytes.
     */
    @Deprecated
    public static int hash32(final String data) {
<span class="fc" id="L260">        final byte[] bytes = StringUtils.getBytesUtf8(data);</span>
<span class="fc" id="L261">        return hash32(bytes, 0, bytes.length, DEFAULT_SEED);</span>
    }

    /**
     * Generates 32-bit hash from the byte array with the given length and a default seed.
     * This is a helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 104729;
     * int hash = MurmurHash3.hash32(data, offset, length, seed);
     * &lt;/pre&gt;
     *
     * &lt;p&gt;This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.&lt;p&gt;
     *
     * @param data The input byte array
     * @param length The length of array
     * @return The 32-bit hash
     * @see #hash32(byte[], int, int, int)
     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.
     */
    @Deprecated
    public static int hash32(final byte[] data, final int length) {
<span class="fc" id="L286">        return hash32(data, length, DEFAULT_SEED);</span>
    }

    /**
     * Generates 32-bit hash from the byte array with the given length and seed. This is a
     * helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int hash = MurmurHash3.hash32(data, offset, length, seed);
     * &lt;/pre&gt;
     *
     * &lt;p&gt;This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.&lt;p&gt;
     *
     * @param data The input byte array
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 32-bit hash
     * @see #hash32(byte[], int, int, int)
     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.
     */
    @Deprecated
    public static int hash32(final byte[] data, final int length, final int seed) {
<span class="fc" id="L311">        return hash32(data, 0, length, seed);</span>
    }

    /**
     * Generates 32-bit hash from the byte array with the given offset, length and seed.
     *
     * &lt;p&gt;This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}
     * from from Austin Applyby's original MurmurHash3 {@code c++} code in SMHasher.&lt;/p&gt;
     *
     * &lt;p&gt;This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.&lt;p&gt;
     *
     * @param data The input byte array
     * @param offset The offset of data
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 32-bit hash
     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.
     */
    @Deprecated
    public static int hash32(final byte[] data, final int offset, final int length, final int seed) {
<span class="fc" id="L333">        int hash = seed;</span>
<span class="fc" id="L334">        final int nblocks = length &gt;&gt; 2;</span>

        // body
<span class="fc bfc" id="L337" title="All 2 branches covered.">        for (int i = 0; i &lt; nblocks; i++) {</span>
<span class="fc" id="L338">            final int index = offset + (i &lt;&lt; 2);</span>
<span class="fc" id="L339">            final int k = getLittleEndianInt(data, index);</span>
<span class="fc" id="L340">            hash = mix32(k, hash);</span>
        }

        // tail
        // ************
        // Note: This fails to apply masking using 0xff to the 3 remaining bytes.
        // ************
<span class="fc" id="L347">        final int index = offset + (nblocks &lt;&lt; 2);</span>
<span class="fc" id="L348">        int k1 = 0;</span>
<span class="fc bfc" id="L349" title="All 4 branches covered.">        switch (offset + length - index) {</span>
        case 3:
<span class="fc" id="L351">            k1 ^= data[index + 2] &lt;&lt; 16;</span>
        case 2:
<span class="fc" id="L353">            k1 ^= data[index + 1] &lt;&lt; 8;</span>
        case 1:
<span class="fc" id="L355">            k1 ^= data[index];</span>

            // mix functions
<span class="fc" id="L358">            k1 *= C1_32;</span>
<span class="fc" id="L359">            k1 = Integer.rotateLeft(k1, R1_32);</span>
<span class="fc" id="L360">            k1 *= C2_32;</span>
<span class="fc" id="L361">            hash ^= k1;</span>
        }

<span class="fc" id="L364">        hash ^= length;</span>
<span class="fc" id="L365">        return fmix32(hash);</span>
    }

    /**
     * Generates 32-bit hash from the byte array with a seed of zero.
     * This is a helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 0;
     * int hash = MurmurHash3.hash32x86(data, offset, data.length, seed);
     * &lt;/pre&gt;
     *
     * @param data The input byte array
     * @return The 32-bit hash
     * @see #hash32x86(byte[], int, int, int)
     * @since 1.14
     */
    public static int hash32x86(final byte[] data) {
<span class="fc" id="L384">        return hash32x86(data, 0, data.length, 0);</span>
    }

    /**
     * Generates 32-bit hash from the byte array with the given offset, length and seed.
     *
     * &lt;p&gt;This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}
     * from from Austin Applyby's original MurmurHash3 {@code c++} code in SMHasher.&lt;/p&gt;
     *
     * @param data The input byte array
     * @param offset The offset of data
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 32-bit hash
     * @since 1.14
     */
    public static int hash32x86(final byte[] data, final int offset, final int length, final int seed) {
<span class="fc" id="L401">        int hash = seed;</span>
<span class="fc" id="L402">        final int nblocks = length &gt;&gt; 2;</span>

        // body
<span class="fc bfc" id="L405" title="All 2 branches covered.">        for (int i = 0; i &lt; nblocks; i++) {</span>
<span class="fc" id="L406">            final int index = offset + (i &lt;&lt; 2);</span>
<span class="fc" id="L407">            final int k = getLittleEndianInt(data, index);</span>
<span class="fc" id="L408">            hash = mix32(k, hash);</span>
        }

        // tail
<span class="fc" id="L412">        final int index = offset + (nblocks &lt;&lt; 2);</span>
<span class="fc" id="L413">        int k1 = 0;</span>
<span class="fc bfc" id="L414" title="All 4 branches covered.">        switch (offset + length - index) {</span>
        case 3:
<span class="fc" id="L416">            k1 ^= (data[index + 2] &amp; 0xff) &lt;&lt; 16;</span>
        case 2:
<span class="fc" id="L418">            k1 ^= (data[index + 1] &amp; 0xff) &lt;&lt; 8;</span>
        case 1:
<span class="fc" id="L420">            k1 ^= (data[index] &amp; 0xff);</span>

            // mix functions
<span class="fc" id="L423">            k1 *= C1_32;</span>
<span class="fc" id="L424">            k1 = Integer.rotateLeft(k1, R1_32);</span>
<span class="fc" id="L425">            k1 *= C2_32;</span>
<span class="fc" id="L426">            hash ^= k1;</span>
        }

<span class="fc" id="L429">        hash ^= length;</span>
<span class="fc" id="L430">        return fmix32(hash);</span>
    }

    /**
     * Generates 64-bit hash from a long with a default seed.
     *
     * &lt;p&gt;&lt;strong&gt;This is not part of the original MurmurHash3 {@code c++} implementation.&lt;/strong&gt;&lt;/p&gt;
     *
     * &lt;p&gt;This is a Murmur3-like 64-bit variant.
     * The method does not produce the same result as either half of the hash bytes from
     * {@linkplain #hash128x64(byte[])} with the same byte data from the {@code long}.
     * This method will be removed in a future release.&lt;/p&gt;
     *
     * &lt;p&gt;Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.&lt;/p&gt;
     *
     * &lt;p&gt;This is a helper method that will produce the same result as:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 104729;
     * long hash = MurmurHash3.hash64(ByteBuffer.allocate(8)
     *                                          .putLong(data)
     *                                          .array(), offset, 8, seed);
     * &lt;/pre&gt;
     *
     * @param data The long to hash
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int, int)
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[])} with the bytes from the {@code long}.
     */
    @Deprecated
    public static long hash64(final long data) {
<span class="fc" id="L464">        long hash = DEFAULT_SEED;</span>
<span class="fc" id="L465">        long k = Long.reverseBytes(data);</span>
<span class="fc" id="L466">        final int length = LONG_BYTES;</span>
        // mix functions
<span class="fc" id="L468">        k *= C1;</span>
<span class="fc" id="L469">        k = Long.rotateLeft(k, R1);</span>
<span class="fc" id="L470">        k *= C2;</span>
<span class="fc" id="L471">        hash ^= k;</span>
<span class="fc" id="L472">        hash = Long.rotateLeft(hash, R2) * M + N1;</span>
        // finalization
<span class="fc" id="L474">        hash ^= length;</span>
<span class="fc" id="L475">        hash = fmix64(hash);</span>
<span class="fc" id="L476">        return hash;</span>
    }

    /**
     * Generates 64-bit hash from an int with a default seed.
     *
     * &lt;p&gt;&lt;strong&gt;This is not part of the original MurmurHash3 {@code c++} implementation.&lt;/strong&gt;&lt;/p&gt;
     *
     * &lt;p&gt;This is a Murmur3-like 64-bit variant.
     * The method does not produce the same result as either half of the hash bytes from
     * {@linkplain #hash128x64(byte[])} with the same byte data from the {@code int}.
     * This method will be removed in a future release.&lt;/p&gt;
     *
     * &lt;p&gt;Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.&lt;/p&gt;
     *
     * &lt;p&gt;This is a helper method that will produce the same result as:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 104729;
     * long hash = MurmurHash3.hash64(ByteBuffer.allocate(4)
     *                                          .putInt(data)
     *                                          .array(), offset, 4, seed);
     * &lt;/pre&gt;
     *
     * @param data The int to hash
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int, int)
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[])} with the bytes from the {@code int}.
     */
    @Deprecated
    public static long hash64(final int data) {
<span class="fc" id="L510">        long k1 = Integer.reverseBytes(data) &amp; (-1L &gt;&gt;&gt; 32);</span>
<span class="fc" id="L511">        final int length = INTEGER_BYTES;</span>
<span class="fc" id="L512">        long hash = DEFAULT_SEED;</span>
<span class="fc" id="L513">        k1 *= C1;</span>
<span class="fc" id="L514">        k1 = Long.rotateLeft(k1, R1);</span>
<span class="fc" id="L515">        k1 *= C2;</span>
<span class="fc" id="L516">        hash ^= k1;</span>
        // finalization
<span class="fc" id="L518">        hash ^= length;</span>
<span class="fc" id="L519">        hash = fmix64(hash);</span>
<span class="fc" id="L520">        return hash;</span>
    }

    /**
     * Generates 64-bit hash from a short with a default seed.
     *
     * &lt;p&gt;&lt;strong&gt;This is not part of the original MurmurHash3 {@code c++} implementation.&lt;/strong&gt;&lt;/p&gt;
     *
     * &lt;p&gt;This is a Murmur3-like 64-bit variant.
     * The method does not produce the same result as either half of the hash bytes from
     * {@linkplain #hash128x64(byte[])} with the same byte data from the {@code short}.
     * This method will be removed in a future release.&lt;/p&gt;
     *
     * &lt;p&gt;Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.&lt;/p&gt;
     *
     * &lt;p&gt;This is a helper method that will produce the same result as:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 104729;
     * long hash = MurmurHash3.hash64(ByteBuffer.allocate(2)
     *                                          .putShort(data)
     *                                          .array(), offset, 2, seed);
     * &lt;/pre&gt;
     *
     * @param data The short to hash
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int, int)
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[])} with the bytes from the {@code short}.
     */
    @Deprecated
    public static long hash64(final short data) {
<span class="fc" id="L554">        long hash = DEFAULT_SEED;</span>
<span class="fc" id="L555">        long k1 = 0;</span>
<span class="fc" id="L556">        k1 ^= ((long) data &amp; 0xff) &lt;&lt; 8;</span>
<span class="fc" id="L557">        k1 ^= ((long) ((data &amp; 0xFF00) &gt;&gt; 8) &amp; 0xff);</span>
<span class="fc" id="L558">        k1 *= C1;</span>
<span class="fc" id="L559">        k1 = Long.rotateLeft(k1, R1);</span>
<span class="fc" id="L560">        k1 *= C2;</span>
<span class="fc" id="L561">        hash ^= k1;</span>

        // finalization
<span class="fc" id="L564">        hash ^= SHORT_BYTES;</span>
<span class="fc" id="L565">        hash = fmix64(hash);</span>
<span class="fc" id="L566">        return hash;</span>
    }

    /**
     * Generates 64-bit hash from a byte array with a default seed.
     *
     * &lt;p&gt;&lt;strong&gt;This is not part of the original MurmurHash3 {@code c++} implementation.&lt;/strong&gt;&lt;/p&gt;
     *
     * &lt;p&gt;This is a Murmur3-like 64-bit variant.
     * The method does not produce the same result as either half of the hash bytes from
     * {@linkplain #hash128x64(byte[])} with the same byte data.
     * This method will be removed in a future release.&lt;/p&gt;
     *
     * &lt;p&gt;Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.&lt;/p&gt;
     *
     * &lt;p&gt;This is a helper method that will produce the same result as:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 104729;
     * long hash = MurmurHash3.hash64(data, offset, data.length, seed);
     * &lt;/pre&gt;
     *
     * @param data The input byte array
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int, int)
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[])}.
     */
    @Deprecated
    public static long hash64(final byte[] data) {
<span class="fc" id="L598">        return hash64(data, 0, data.length, DEFAULT_SEED);</span>
    }

    /**
     * Generates 64-bit hash from a byte array with the given offset and length and a default seed.
     *
     * &lt;p&gt;&lt;strong&gt;This is not part of the original MurmurHash3 {@code c++} implementation.&lt;/strong&gt;&lt;/p&gt;
     *
     * &lt;p&gt;This is a Murmur3-like 64-bit variant.
     * The method does not produce the same result as either half of the hash bytes from
     * {@linkplain #hash128x64(byte[])} with the same byte data.
     * This method will be removed in a future release.&lt;/p&gt;
     *
     * &lt;p&gt;Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.&lt;/p&gt;
     *
     * &lt;p&gt;This is a helper method that will produce the same result as:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * int seed = 104729;
     * long hash = MurmurHash3.hash64(data, offset, length, seed);
     * &lt;/pre&gt;
     *
     * @param data The input byte array
     * @param offset The offset of data
     * @param length The length of array
     * @return The 64-bit hash
     * @see #hash64(byte[], int, int, int)
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[], int, int, int)}.
     */
    @Deprecated
    public static long hash64(final byte[] data, final int offset, final int length) {
<span class="fc" id="L631">        return hash64(data, offset, length, DEFAULT_SEED);</span>
    }

    /**
     * Generates 64-bit hash from a byte array with the given offset, length and seed.
     *
     * &lt;p&gt;&lt;strong&gt;This is not part of the original MurmurHash3 {@code c++} implementation.&lt;/strong&gt;&lt;/p&gt;
     *
     * &lt;p&gt;This is a Murmur3-like 64-bit variant.
     * This method will be removed in a future release.&lt;/p&gt;
     *
     * &lt;p&gt;This implementation contains a sign-extension bug in the seed initialization.
     * This manifests if the seed is negative.&lt;/p&gt;
     *
     * &lt;p&gt;This algorithm processes 8 bytes chunks of data in a manner similar to the 16 byte chunks
     * of data processed in the MurmurHash3 {@code MurmurHash3_x64_128} method. However the hash
     * is not mixed with a hash chunk from the next 8 bytes of data. The method will not return
     * the same value as the first or second 64-bits of the function
     * {@link #hash128(byte[], int, int, int)}.&lt;/p&gt;
     *
     * &lt;p&gt;Use of this method is not advised. Use the first long returned from
     * {@link #hash128x64(byte[], int, int, int)}.&lt;p&gt;
     *
     * @param data The input byte array
     * @param offset The offset of data
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 64-bit hash
     * @deprecated Not part of the MurmurHash3 implementation.
     * Use half of the hash bytes from {@link #hash128x64(byte[], int, int, int)}.
     */
    @Deprecated
    public static long hash64(final byte[] data, final int offset, final int length, final int seed) {
        // ************
        // Note: This fails to apply masking using 0xffffffffL to the seed.
        // ************
<span class="fc" id="L667">        long hash = seed;</span>
<span class="fc" id="L668">        final int nblocks = length &gt;&gt; 3;</span>

        // body
<span class="fc bfc" id="L671" title="All 2 branches covered.">        for (int i = 0; i &lt; nblocks; i++) {</span>
<span class="fc" id="L672">            final int index = offset + (i &lt;&lt; 3);</span>
<span class="fc" id="L673">            long k = getLittleEndianLong(data, index);</span>

            // mix functions
<span class="fc" id="L676">            k *= C1;</span>
<span class="fc" id="L677">            k = Long.rotateLeft(k, R1);</span>
<span class="fc" id="L678">            k *= C2;</span>
<span class="fc" id="L679">            hash ^= k;</span>
<span class="fc" id="L680">            hash = Long.rotateLeft(hash, R2) * M + N1;</span>
        }

        // tail
<span class="fc" id="L684">        long k1 = 0;</span>
<span class="fc" id="L685">        final int index = offset + (nblocks &lt;&lt; 3);</span>
<span class="fc bfc" id="L686" title="All 8 branches covered.">        switch (offset + length - index) {</span>
        case 7:
<span class="fc" id="L688">            k1 ^= ((long) data[index + 6] &amp; 0xff) &lt;&lt; 48;</span>
        case 6:
<span class="fc" id="L690">            k1 ^= ((long) data[index + 5] &amp; 0xff) &lt;&lt; 40;</span>
        case 5:
<span class="fc" id="L692">            k1 ^= ((long) data[index + 4] &amp; 0xff) &lt;&lt; 32;</span>
        case 4:
<span class="fc" id="L694">            k1 ^= ((long) data[index + 3] &amp; 0xff) &lt;&lt; 24;</span>
        case 3:
<span class="fc" id="L696">            k1 ^= ((long) data[index + 2] &amp; 0xff) &lt;&lt; 16;</span>
        case 2:
<span class="fc" id="L698">            k1 ^= ((long) data[index + 1] &amp; 0xff) &lt;&lt; 8;</span>
        case 1:
<span class="fc" id="L700">            k1 ^= ((long) data[index] &amp; 0xff);</span>
<span class="fc" id="L701">            k1 *= C1;</span>
<span class="fc" id="L702">            k1 = Long.rotateLeft(k1, R1);</span>
<span class="fc" id="L703">            k1 *= C2;</span>
<span class="fc" id="L704">            hash ^= k1;</span>
        }

        // finalization
<span class="fc" id="L708">        hash ^= length;</span>
<span class="fc" id="L709">        hash = fmix64(hash);</span>

<span class="fc" id="L711">        return hash;</span>
    }

    /**
     * Generates 128-bit hash from the byte array with a default seed.
     * This is a helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 104729;
     * int hash = MurmurHash3.hash128(data, offset, data.length, seed);
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Note: The sign extension bug in {@link #hash128(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.&lt;/p&gt;
     *
     * @param data The input byte array
     * @return The 128-bit hash (2 longs)
     * @see #hash128(byte[], int, int, int)
     */
    public static long[] hash128(final byte[] data) {
<span class="fc" id="L732">        return hash128(data, 0, data.length, DEFAULT_SEED);</span>
    }

    /**
     * Generates 128-bit hash from the byte array with a seed of zero.
     * This is a helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 0;
     * int hash = MurmurHash3.hash128x64(data, offset, data.length, seed);
     * &lt;/pre&gt;
     *
     * @param data The input byte array
     * @return The 128-bit hash (2 longs)
     * @see #hash128x64(byte[], int, int, int)
     * @since 1.14
     */
    public static long[] hash128x64(final byte[] data) {
<span class="fc" id="L751">        return hash128x64(data, 0, data.length, 0);</span>
    }

    /**
     * Generates 128-bit hash from a string with a default seed.
     * &lt;p&gt;
     * Before 1.14 the string was converted using default encoding.
     * Since 1.14 the string is converted to bytes using UTF-8 encoding.
     * &lt;/p&gt;
     * This is a helper method that will produce the same result as:
     *
     * &lt;pre&gt;
     * int offset = 0;
     * int seed = 104729;
     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);
     * int hash = MurmurHash3.hash128(bytes, offset, bytes.length, seed);
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Note: The sign extension bug in {@link #hash128(byte[], int, int, int)} does not effect
     * this result as the default seed is positive.&lt;/p&gt;
     *
     * @param data The input String
     * @return The 128-bit hash (2 longs)
     * @see #hash128(byte[], int, int, int)
     * @deprecated Use {@link #hash128x64(byte[])} using the bytes returned from
     * {@link String#getBytes(java.nio.charset.Charset)}.
     */
    @Deprecated
    public static long[] hash128(final String data) {
<span class="fc" id="L780">        final byte[] bytes = StringUtils.getBytesUtf8(data);</span>
<span class="fc" id="L781">        return hash128(bytes, 0, bytes.length, DEFAULT_SEED);</span>
    }

    /**
     * Generates 128-bit hash from the byte array with the given offset, length and seed.
     *
     * &lt;p&gt;This is an implementation of the 128-bit hash function {@code MurmurHash3_x64_128}
     * from from Austin Applyby's original MurmurHash3 {@code c++} code in SMHasher.&lt;/p&gt;
     *
     * &lt;p&gt;This implementation contains a sign-extension bug in the seed initialization.
     * This manifests if the seed is negative.&lt;p&gt;
     *
     * @param data The input byte array
     * @param offset The first element of array
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 128-bit hash (2 longs)
     * @deprecated Use {@link #hash128x64(byte[], int, int, int)}. This corrects the seed initialization.
     */
    @Deprecated
    public static long[] hash128(final byte[] data, final int offset, final int length, final int seed) {
        // ************
        // Note: This fails to apply masking using 0xffffffffL to the seed.
        // ************
<span class="fc" id="L805">        return hash128x64(data, offset, length, seed);</span>
    }

    /**
     * Generates 128-bit hash from the byte array with the given offset, length and seed.
     *
     * &lt;p&gt;This is an implementation of the 128-bit hash function {@code MurmurHash3_x64_128}
     * from from Austin Applyby's original MurmurHash3 {@code c++} code in SMHasher.&lt;/p&gt;
     *
     * @param data The input byte array
     * @param offset The first element of array
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 128-bit hash (2 longs)
     * @since 1.14
     */
    public static long[] hash128x64(final byte[] data, final int offset, final int length, final int seed) {
        // Use an unsigned 32-bit integer as the seed
<span class="fc" id="L823">        return hash128x64(data, offset, length, seed &amp; 0xffffffffL);</span>
    }

    /**
     * Generates 128-bit hash from the byte array with the given offset, length and seed.
     *
     * &lt;p&gt;This is an implementation of the 128-bit hash function {@code MurmurHash3_x64_128}
     * from from Austin Applyby's original MurmurHash3 {@code c++} code in SMHasher.&lt;/p&gt;
     *
     * @param data The input byte array
     * @param offset The first element of array
     * @param length The length of array
     * @param seed The initial seed value
     * @return The 128-bit hash (2 longs)
     */
    private static long[] hash128x64(final byte[] data, final int offset, final int length, final long seed) {
<span class="fc" id="L839">        long h1 = seed;</span>
<span class="fc" id="L840">        long h2 = seed;</span>
<span class="fc" id="L841">        final int nblocks = length &gt;&gt; 4;</span>

        // body
<span class="fc bfc" id="L844" title="All 2 branches covered.">        for (int i = 0; i &lt; nblocks; i++) {</span>
<span class="fc" id="L845">            final int index = offset + (i &lt;&lt; 4);</span>
<span class="fc" id="L846">            long k1 = getLittleEndianLong(data, index);</span>
<span class="fc" id="L847">            long k2 = getLittleEndianLong(data, index + 8);</span>

            // mix functions for k1
<span class="fc" id="L850">            k1 *= C1;</span>
<span class="fc" id="L851">            k1 = Long.rotateLeft(k1, R1);</span>
<span class="fc" id="L852">            k1 *= C2;</span>
<span class="fc" id="L853">            h1 ^= k1;</span>
<span class="fc" id="L854">            h1 = Long.rotateLeft(h1, R2);</span>
<span class="fc" id="L855">            h1 += h2;</span>
<span class="fc" id="L856">            h1 = h1 * M + N1;</span>

            // mix functions for k2
<span class="fc" id="L859">            k2 *= C2;</span>
<span class="fc" id="L860">            k2 = Long.rotateLeft(k2, R3);</span>
<span class="fc" id="L861">            k2 *= C1;</span>
<span class="fc" id="L862">            h2 ^= k2;</span>
<span class="fc" id="L863">            h2 = Long.rotateLeft(h2, R1);</span>
<span class="fc" id="L864">            h2 += h1;</span>
<span class="fc" id="L865">            h2 = h2 * M + N2;</span>
        }

        // tail
<span class="fc" id="L869">        long k1 = 0;</span>
<span class="fc" id="L870">        long k2 = 0;</span>
<span class="fc" id="L871">        final int index = offset + (nblocks &lt;&lt; 4);</span>
<span class="fc bfc" id="L872" title="All 16 branches covered.">        switch (offset + length - index) {</span>
        case 15:
<span class="fc" id="L874">            k2 ^= ((long) data[index + 14] &amp; 0xff) &lt;&lt; 48;</span>
        case 14:
<span class="fc" id="L876">            k2 ^= ((long) data[index + 13] &amp; 0xff) &lt;&lt; 40;</span>
        case 13:
<span class="fc" id="L878">            k2 ^= ((long) data[index + 12] &amp; 0xff) &lt;&lt; 32;</span>
        case 12:
<span class="fc" id="L880">            k2 ^= ((long) data[index + 11] &amp; 0xff) &lt;&lt; 24;</span>
        case 11:
<span class="fc" id="L882">            k2 ^= ((long) data[index + 10] &amp; 0xff) &lt;&lt; 16;</span>
        case 10:
<span class="fc" id="L884">            k2 ^= ((long) data[index + 9] &amp; 0xff) &lt;&lt; 8;</span>
        case 9:
<span class="fc" id="L886">            k2 ^= data[index + 8] &amp; 0xff;</span>
<span class="fc" id="L887">            k2 *= C2;</span>
<span class="fc" id="L888">            k2 = Long.rotateLeft(k2, R3);</span>
<span class="fc" id="L889">            k2 *= C1;</span>
<span class="fc" id="L890">            h2 ^= k2;</span>

        case 8:
<span class="fc" id="L893">            k1 ^= ((long) data[index + 7] &amp; 0xff) &lt;&lt; 56;</span>
        case 7:
<span class="fc" id="L895">            k1 ^= ((long) data[index + 6] &amp; 0xff) &lt;&lt; 48;</span>
        case 6:
<span class="fc" id="L897">            k1 ^= ((long) data[index + 5] &amp; 0xff) &lt;&lt; 40;</span>
        case 5:
<span class="fc" id="L899">            k1 ^= ((long) data[index + 4] &amp; 0xff) &lt;&lt; 32;</span>
        case 4:
<span class="fc" id="L901">            k1 ^= ((long) data[index + 3] &amp; 0xff) &lt;&lt; 24;</span>
        case 3:
<span class="fc" id="L903">            k1 ^= ((long) data[index + 2] &amp; 0xff) &lt;&lt; 16;</span>
        case 2:
<span class="fc" id="L905">            k1 ^= ((long) data[index + 1] &amp; 0xff) &lt;&lt; 8;</span>
        case 1:
<span class="fc" id="L907">            k1 ^= data[index] &amp; 0xff;</span>
<span class="fc" id="L908">            k1 *= C1;</span>
<span class="fc" id="L909">            k1 = Long.rotateLeft(k1, R1);</span>
<span class="fc" id="L910">            k1 *= C2;</span>
<span class="fc" id="L911">            h1 ^= k1;</span>
        }

        // finalization
<span class="fc" id="L915">        h1 ^= length;</span>
<span class="fc" id="L916">        h2 ^= length;</span>

<span class="fc" id="L918">        h1 += h2;</span>
<span class="fc" id="L919">        h2 += h1;</span>

<span class="fc" id="L921">        h1 = fmix64(h1);</span>
<span class="fc" id="L922">        h2 = fmix64(h2);</span>

<span class="fc" id="L924">        h1 += h2;</span>
<span class="fc" id="L925">        h2 += h1;</span>

<span class="fc" id="L927">        return new long[] { h1, h2 };</span>
    }

    /**
     * Gets the little-endian long from 8 bytes starting at the specified index.
     *
     * @param data The data
     * @param index The index
     * @return The little-endian long
     */
    private static long getLittleEndianLong(final byte[] data, final int index) {
<span class="fc" id="L938">        return (((long) data[index    ] &amp; 0xff)      ) |</span>
               (((long) data[index + 1] &amp; 0xff) &lt;&lt;  8) |
               (((long) data[index + 2] &amp; 0xff) &lt;&lt; 16) |
               (((long) data[index + 3] &amp; 0xff) &lt;&lt; 24) |
               (((long) data[index + 4] &amp; 0xff) &lt;&lt; 32) |
               (((long) data[index + 5] &amp; 0xff) &lt;&lt; 40) |
               (((long) data[index + 6] &amp; 0xff) &lt;&lt; 48) |
               (((long) data[index + 7] &amp; 0xff) &lt;&lt; 56);
    }

    /**
     * Gets the little-endian int from 4 bytes starting at the specified index.
     *
     * @param data The data
     * @param index The index
     * @return The little-endian int
     */
    private static int getLittleEndianInt(final byte[] data, final int index) {
<span class="fc" id="L956">        return ((data[index    ] &amp; 0xff)      ) |</span>
               ((data[index + 1] &amp; 0xff) &lt;&lt;  8) |
               ((data[index + 2] &amp; 0xff) &lt;&lt; 16) |
               ((data[index + 3] &amp; 0xff) &lt;&lt; 24);
    }

    /**
     * Performs the intermediate mix step of the 32-bit hash function {@code MurmurHash3_x86_32}.
     *
     * @param k The data to add to the hash
     * @param hash The current hash
     * @return The new hash
     */
    private static int mix32(int k, int hash) {
<span class="fc" id="L970">        k *= C1_32;</span>
<span class="fc" id="L971">        k = Integer.rotateLeft(k, R1_32);</span>
<span class="fc" id="L972">        k *= C2_32;</span>
<span class="fc" id="L973">        hash ^= k;</span>
<span class="fc" id="L974">        return Integer.rotateLeft(hash, R2_32) * M_32 + N_32;</span>
    }

    /**
     * Performs the final avalanche mix step of the 32-bit hash function {@code MurmurHash3_x86_32}.
     *
     * @param hash The current hash
     * @return The final hash
     */
    private static int fmix32(int hash) {
<span class="fc" id="L984">        hash ^= (hash &gt;&gt;&gt; 16);</span>
<span class="fc" id="L985">        hash *= 0x85ebca6b;</span>
<span class="fc" id="L986">        hash ^= (hash &gt;&gt;&gt; 13);</span>
<span class="fc" id="L987">        hash *= 0xc2b2ae35;</span>
<span class="fc" id="L988">        hash ^= (hash &gt;&gt;&gt; 16);</span>
<span class="fc" id="L989">        return hash;</span>
    }

    /**
     * Performs the final avalanche mix step of the 64-bit hash function {@code MurmurHash3_x64_128}.
     *
     * @param hash The current hash
     * @return The final hash
     */
    private static long fmix64(long hash) {
<span class="fc" id="L999">        hash ^= (hash &gt;&gt;&gt; 33);</span>
<span class="fc" id="L1000">        hash *= 0xff51afd7ed558ccdL;</span>
<span class="fc" id="L1001">        hash ^= (hash &gt;&gt;&gt; 33);</span>
<span class="fc" id="L1002">        hash *= 0xc4ceb9fe1a85ec53L;</span>
<span class="fc" id="L1003">        hash ^= (hash &gt;&gt;&gt; 33);</span>
<span class="fc" id="L1004">        return hash;</span>
    }

    /**
     * Generates 32-bit hash from input bytes. Bytes can be added incrementally and the new
     * hash computed.
     *
     * &lt;p&gt;This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}
     * from from Austin Applyby's original MurmurHash3 {@code c++} code in SMHasher.&lt;/p&gt;
     *
     * @since 1.14
     */
<span class="fc" id="L1016">    public static class IncrementalHash32x86 {</span>

        /** The size of byte blocks that are processed together. */
        private static final int BLOCK_SIZE = 4;

        /** Up to 3 unprocessed bytes from input data. */
<span class="fc" id="L1022">        private final byte[] unprocessed = new byte[3];</span>

        /** The number of unprocessed bytes in the tail data. */
        private int unprocessedLength;

        /** The total number of input bytes added since the start. */
        private int totalLen;

        /**
         * The current running hash.
         * This must be finalised to generate the 32-bit hash value.
         */
        private int hash;

        /**
         * Starts a new incremental hash.
         *
         * @param seed The initial seed value
         */
        public final void start(final int seed) {
            // Reset
<span class="fc" id="L1043">            unprocessedLength = totalLen = 0;</span>
<span class="fc" id="L1044">            this.hash = seed;</span>
<span class="fc" id="L1045">        }</span>

        /**
         * Adds the byte array to the current incremental hash.
         *
         * @param data The input byte array
         * @param offset The offset of data
         * @param length The length of array
         */
        public final void add(final byte[] data, final int offset, final int length) {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            if (length &lt;= 0) {</span>
                // Nothing to add
<span class="fc" id="L1057">                return;</span>
            }
<span class="fc" id="L1059">            totalLen += length;</span>

            // Process the bytes in blocks of 4.
            // New bytes must be added to any current unprocessed bytes,
            // then processed in blocks of 4 and the remaining bytes saved:
            //
            //    |--|---------------------------|--|
            // unprocessed
            //                main block
            //                                remaining

            // Check if the unprocessed bytes and new bytes can fill a block of 4.
            // Make this overflow safe in the event that length is Integer.MAX_VALUE.
            // Equivalent to: (unprocessedLength + length &lt; BLOCK_SIZE)
<span class="fc bfc" id="L1073" title="All 2 branches covered.">            if (unprocessedLength + length - BLOCK_SIZE &lt; 0) {</span>
                // Not enough so add to the unprocessed bytes
<span class="fc" id="L1075">                System.arraycopy(data, offset, unprocessed, unprocessedLength, length);</span>
<span class="fc" id="L1076">                unprocessedLength += length;</span>
<span class="fc" id="L1077">                return;</span>
            }

            // Combine unprocessed bytes with new bytes.
            int newOffset;
            int newLength;
<span class="fc bfc" id="L1083" title="All 2 branches covered.">            if (unprocessedLength &gt; 0) {</span>
<span class="fc" id="L1084">                int k = -1;</span>
<span class="pc bpc" id="L1085" title="1 of 4 branches missed.">                switch (unprocessedLength) {</span>
                case 1:
<span class="fc" id="L1087">                    k = orBytes(unprocessed[0], data[offset], data[offset + 1], data[offset + 2]);</span>
<span class="fc" id="L1088">                    break;</span>
                case 2:
<span class="fc" id="L1090">                    k = orBytes(unprocessed[0], unprocessed[1], data[offset], data[offset + 1]);</span>
<span class="fc" id="L1091">                    break;</span>
                case 3:
<span class="fc" id="L1093">                    k = orBytes(unprocessed[0], unprocessed[1], unprocessed[2], data[offset]);</span>
<span class="fc" id="L1094">                    break;</span>
                default:
<span class="nc" id="L1096">                    throw new IllegalStateException(&quot;Unprocessed length should be 1, 2, or 3: &quot; + unprocessedLength);</span>
                }
<span class="fc" id="L1098">                hash = mix32(k, hash);</span>
                // Update the offset and length
<span class="fc" id="L1100">                final int consumed = BLOCK_SIZE - unprocessedLength;</span>
<span class="fc" id="L1101">                newOffset = offset + consumed;</span>
<span class="fc" id="L1102">                newLength = length - consumed;</span>
<span class="fc" id="L1103">            } else {</span>
<span class="fc" id="L1104">                newOffset = offset;</span>
<span class="fc" id="L1105">                newLength = length;</span>
            }

            // Main processing of blocks of 4 bytes
<span class="fc" id="L1109">            final int nblocks = newLength &gt;&gt; 2;</span>

<span class="fc bfc" id="L1111" title="All 2 branches covered.">            for (int i = 0; i &lt; nblocks; i++) {</span>
<span class="fc" id="L1112">                final int index = newOffset + (i &lt;&lt; 2);</span>
<span class="fc" id="L1113">                final int k = getLittleEndianInt(data, index);</span>
<span class="fc" id="L1114">                hash = mix32(k, hash);</span>
            }

            // Save left-over unprocessed bytes
<span class="fc" id="L1118">            final int consumed = (nblocks &lt;&lt; 2);</span>
<span class="fc" id="L1119">            unprocessedLength = newLength - consumed;</span>
<span class="fc bfc" id="L1120" title="All 2 branches covered.">            if (unprocessedLength != 0) {</span>
<span class="fc" id="L1121">                System.arraycopy(data, newOffset + consumed, unprocessed, 0, unprocessedLength);</span>
            }
<span class="fc" id="L1123">        }</span>

        /**
         * Generate the 32-bit hash value. Repeat calls to this method with no additional data
         * will generate the same hash value.
         *
         * @return The 32-bit hash
         */
        public final int end() {
            // Allow calling end() again after adding no data to return the same result.
<span class="fc" id="L1133">            return finalise(hash, unprocessedLength, unprocessed, totalLen);</span>
        }

        /**
         * Finalize the running hash to the output 32-bit hash by processing remaining bytes
         * and performing final mixing.
         *
         * @param hash The running hash
         * @param unprocessedLength The number of unprocessed bytes in the tail data.
         * @param unprocessed Up to 3 unprocessed bytes from input data.
         * @param totalLen The total number of input bytes added since the start.
         * @return The 32-bit hash
         */
        int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
<span class="fc" id="L1147">            int result = hash;</span>
<span class="fc" id="L1148">            int k1 = 0;</span>
<span class="fc bfc" id="L1149" title="All 4 branches covered.">            switch (unprocessedLength) {</span>
            case 3:
<span class="fc" id="L1151">                k1 ^= (unprocessed[2] &amp; 0xff) &lt;&lt; 16;</span>
            case 2:
<span class="fc" id="L1153">                k1 ^= (unprocessed[1] &amp; 0xff) &lt;&lt; 8;</span>
            case 1:
<span class="fc" id="L1155">                k1 ^= (unprocessed[0] &amp; 0xff);</span>

                // mix functions
<span class="fc" id="L1158">                k1 *= C1_32;</span>
<span class="fc" id="L1159">                k1 = Integer.rotateLeft(k1, R1_32);</span>
<span class="fc" id="L1160">                k1 *= C2_32;</span>
<span class="fc" id="L1161">                result ^= k1;</span>
            }

            // finalization
<span class="fc" id="L1165">            result ^= totalLen;</span>
<span class="fc" id="L1166">            return fmix32(result);</span>
        }

        /**
         * Combines the bytes using an Or operation ({@code | } in a little-endian representation
         * of a 32-bit integer; byte 1 will be the least significant byte, byte 4 the most
         * significant.
         *
         * @param b1 The first byte
         * @param b2 The second byte
         * @param b3 The third byte
         * @param b4 The fourth byte
         * @return The 32-bit integer
         */
        private static int orBytes(final byte b1, final byte b2, final byte b3, final byte b4) {
<span class="fc" id="L1181">            return (b1 &amp; 0xff) | ((b2 &amp; 0xff) &lt;&lt; 8) | ((b3 &amp; 0xff) &lt;&lt; 16) | ((b4 &amp; 0xff) &lt;&lt; 24);</span>
        }
    }

    /**
     * Generates 32-bit hash from input bytes. Bytes can be added incrementally and the new
     * hash computed.
     *
     * &lt;p&gt;This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}
     * from from Austin Applyby's original MurmurHash3 {@code c++} code in SMHasher.&lt;/p&gt;
     *
     * &lt;p&gt;This implementation contains a sign-extension bug in the finalization step of
     * any bytes left over from dividing the length by 4. This manifests if any of these
     * bytes are negative.&lt;p&gt;
     *
     * @deprecated Use IncrementalHash32x86. This corrects the processing of trailing bytes.
     */
    @Deprecated
<span class="fc" id="L1199">    public static class IncrementalHash32 extends IncrementalHash32x86 {</span>

        /**
         * {@inheritDoc}
         *
         * &lt;p&gt;This implementation contains a sign-extension bug in the finalization step of
         * any bytes left over from dividing the length by 4. This manifests if any of these
         * bytes are negative.&lt;p&gt;
         *
         * @deprecated Use IncrementalHash32x86. This corrects the processing of trailing bytes.
         */
        @Override
        @Deprecated
        int finalise(final int hash, final int unprocessedLength, final byte[] unprocessed, final int totalLen) {
<span class="fc" id="L1213">            int result = hash;</span>
            // ************
            // Note: This fails to apply masking using 0xff to the 3 remaining bytes.
            // ************
<span class="fc" id="L1217">            int k1 = 0;</span>
<span class="fc bfc" id="L1218" title="All 4 branches covered.">            switch (unprocessedLength) {</span>
            case 3:
<span class="fc" id="L1220">                k1 ^= unprocessed[2] &lt;&lt; 16;</span>
            case 2:
<span class="fc" id="L1222">                k1 ^= unprocessed[1] &lt;&lt; 8;</span>
            case 1:
<span class="fc" id="L1224">                k1 ^= unprocessed[0];</span>

                // mix functions
<span class="fc" id="L1227">                k1 *= C1_32;</span>
<span class="fc" id="L1228">                k1 = Integer.rotateLeft(k1, R1_32);</span>
<span class="fc" id="L1229">                k1 *= C2_32;</span>
<span class="fc" id="L1230">                result ^= k1;</span>
            }

            // finalization
<span class="fc" id="L1234">            result ^= totalLen;</span>
<span class="fc" id="L1235">            return fmix32(result);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>