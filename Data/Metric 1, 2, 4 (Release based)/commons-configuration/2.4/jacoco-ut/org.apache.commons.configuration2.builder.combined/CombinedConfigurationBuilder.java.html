<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CombinedConfigurationBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Configuration</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2.builder.combined</a> &gt; <span class="el_source">CombinedConfigurationBuilder.java</span></div><h1>CombinedConfigurationBuilder.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.configuration2.builder.combined;

import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.configuration2.CombinedConfiguration;
import org.apache.commons.configuration2.Configuration;
import org.apache.commons.configuration2.ConfigurationLookup;
import org.apache.commons.configuration2.HierarchicalConfiguration;
import org.apache.commons.configuration2.SystemConfiguration;
import org.apache.commons.configuration2.XMLConfiguration;
import org.apache.commons.configuration2.beanutils.BeanDeclaration;
import org.apache.commons.configuration2.beanutils.BeanHelper;
import org.apache.commons.configuration2.beanutils.CombinedBeanDeclaration;
import org.apache.commons.configuration2.beanutils.XMLBeanDeclaration;
import org.apache.commons.configuration2.builder.BasicBuilderParameters;
import org.apache.commons.configuration2.builder.BasicConfigurationBuilder;
import org.apache.commons.configuration2.builder.BuilderParameters;
import org.apache.commons.configuration2.builder.ConfigurationBuilder;
import org.apache.commons.configuration2.builder.ConfigurationBuilderEvent;
import org.apache.commons.configuration2.builder.FileBasedBuilderParametersImpl;
import org.apache.commons.configuration2.builder.FileBasedBuilderProperties;
import org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder;
import org.apache.commons.configuration2.builder.XMLBuilderParametersImpl;
import org.apache.commons.configuration2.builder.XMLBuilderProperties;
import org.apache.commons.configuration2.event.EventListener;
import org.apache.commons.configuration2.ex.ConfigurationException;
import org.apache.commons.configuration2.interpol.ConfigurationInterpolator;
import org.apache.commons.configuration2.interpol.Lookup;
import org.apache.commons.configuration2.io.FileSystem;
import org.apache.commons.configuration2.resolver.CatalogResolver;
import org.apache.commons.configuration2.tree.DefaultExpressionEngineSymbols;
import org.apache.commons.configuration2.tree.OverrideCombiner;
import org.apache.commons.configuration2.tree.UnionCombiner;
import org.xml.sax.EntityResolver;

/**
 * &lt;p&gt;
 * A specialized {@code ConfigurationBuilder} implementation that creates a
 * {@link CombinedConfiguration} from multiple configuration sources defined by
 * an XML-based &lt;em&gt;configuration definition file&lt;/em&gt;.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This class provides an easy and flexible means for loading multiple
 * configuration sources and combining the results into a single configuration
 * object. The sources to be loaded are defined in an XML document that can
 * contain certain tags representing the different supported configuration
 * classes. If such a tag is found, a corresponding {@code ConfigurationBuilder}
 * class is instantiated and initialized using the classes of the
 * {@code beanutils} package (namely
 * {@link org.apache.commons.configuration2.beanutils.XMLBeanDeclaration
 * XMLBeanDeclaration} will be used to extract the configuration's
 * initialization parameters, which allows for complex initialization
 * scenarios).
 * &lt;/p&gt;
 * &lt;p&gt;
 * It is also possible to add custom tags to the configuration definition file.
 * For this purpose an implementation of
 * {@link CombinedConfigurationBuilderProvider} has to be created which is
 * responsible for the creation of a {@code ConfigurationBuilder} associated
 * with the custom tag. An instance of this class has to be registered at the
 * {@link CombinedBuilderParametersImpl} object which is used to initialize this
 * {@code CombinedConfigurationBuilder}. This provider will then be called when
 * the corresponding custom tag is detected. For many default configuration
 * classes providers are already registered.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The configuration definition file has the following basic structure:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;configuration systemProperties=&quot;properties file name&quot;&amp;gt;
 *   &amp;lt;header&amp;gt;
 *     &amp;lt;!-- Optional meta information about the combined configuration --&amp;gt;
 *   &amp;lt;/header&amp;gt;
 *   &amp;lt;override&amp;gt;
 *     &amp;lt;!-- Declarations for override configurations --&amp;gt;
 *   &amp;lt;/override&amp;gt;
 *   &amp;lt;additional&amp;gt;
 *     &amp;lt;!-- Declarations for union configurations --&amp;gt;
 *   &amp;lt;/additional&amp;gt;
 * &amp;lt;/configuration&amp;gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The name of the root element (here {@code configuration}) is arbitrary. The
 * optional {@code systemProperties} attribute identifies the path to a property
 * file containing properties that should be added to the system properties. If
 * specified on the root element, the system properties are set before the rest
 * of the configuration is processed.
 * &lt;/p&gt;
 * &lt;p&gt;
 * There are two sections (both of them are optional) for declaring
 * &lt;em&gt;override&lt;/em&gt; and &lt;em&gt;additional&lt;/em&gt; configurations. Configurations in
 * the former section are evaluated in the order of their declaration, and
 * properties of configurations declared earlier hide those of configurations
 * declared later. Configurations in the latter section are combined to a union
 * configuration, i.e. all of their properties are added to a large hierarchical
 * configuration. Configuration declarations that occur as direct children of
 * the root element are treated as override declarations.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Each configuration declaration consists of a tag whose name is associated
 * with a {@code CombinedConfigurationBuilderProvider}. This can be one of the
 * predefined tags like {@code properties}, or {@code xml}, or a custom tag, for
 * which a configuration builder provider was registered (as described above).
 * Attributes and sub elements with specific initialization parameters can be
 * added. There are some reserved attributes with a special meaning that can be
 * used in every configuration declaration:
 * &lt;/p&gt;
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;Standard attributes for configuration declarations&lt;/caption&gt;
 * &lt;tr&gt;
 * &lt;th&gt;Attribute&lt;/th&gt;
 * &lt;th&gt;Meaning&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;top&quot;&gt;{@code config-name}&lt;/td&gt;
 * &lt;td&gt;Allows specifying a name for this configuration. This name can be used to
 * obtain a reference to the configuration from the resulting combined
 * configuration (see below). It can also be passed to the
 * {@link #getNamedBuilder(String)} method.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;top&quot;&gt;{@code config-at}&lt;/td&gt;
 * &lt;td&gt;With this attribute an optional prefix can be specified for the
 * properties of the corresponding configuration.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;top&quot;&gt;{@code config-optional}&lt;/td&gt;
 * &lt;td&gt;Declares a configuration source as optional. This means that errors that
 * occur when creating the configuration are ignored.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td valign=&quot;top&quot;&gt;{@code config-reload}&lt;/td&gt;
 * &lt;td&gt;Many configuration sources support a reloading mechanism. For those
 * sources it is possible to enable reloading by providing this attribute with a
 * value of &lt;strong&gt;true&lt;/strong&gt;.&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * The optional &lt;em&gt;header&lt;/em&gt; section can contain some meta data about the
 * created configuration itself. For instance, it is possible to set further
 * properties of the {@code NodeCombiner} objects used for constructing the
 * resulting configuration.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The default configuration object returned by this builder is an instance of
 * the {@link CombinedConfiguration} class. This allows for convenient access to
 * the configuration objects maintained by the combined configuration (e.g. for
 * updates of single configuration objects). It has also the advantage that the
 * properties stored in all declared configuration objects are collected and
 * transformed into a single hierarchical structure, which can be accessed using
 * different expression engines. The actual {@code CombinedConfiguration}
 * implementation can be overridden by specifying the class in the
 * &lt;em&gt;config-class&lt;/em&gt; attribute of the result element.
 * &lt;/p&gt;
 * &lt;p&gt;
 * A custom EntityResolver can be used for all XMLConfigurations by adding
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;entity-resolver config-class=&quot;EntityResolver fully qualified class name&quot;&amp;gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * A specific CatalogResolver can be specified for all XMLConfiguration sources
 * by adding
 * &lt;/p&gt;
 * &lt;pre&gt;
 * &amp;lt;entity-resolver catalogFiles=&quot;comma separated list of catalog files&quot;&amp;gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Additional ConfigurationProviders can be added by configuring them in the
 * &lt;em&gt;header&lt;/em&gt; section.
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;providers&amp;gt;
 *   &amp;lt;provider config-tag=&quot;tag name&quot; config-class=&quot;provider fully qualified class name&quot;/&amp;gt;
 * &amp;lt;/providers&amp;gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Additional variable resolvers can be added by configuring them in the
 * &lt;em&gt;header&lt;/em&gt; section.
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;lookups&amp;gt;
 *   &amp;lt;lookup config-prefix=&quot;prefix&quot; config-class=&quot;StrLookup fully qualified class name&quot;/&amp;gt;
 * &amp;lt;/lookups&amp;gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * All declared override configurations are directly added to the resulting
 * combined configuration. If they are given names (using the
 * {@code config-name} attribute), they can directly be accessed using the
 * {@code getConfiguration(String)} method of {@code CombinedConfiguration}. The
 * additional configurations are altogether added to another combined
 * configuration, which uses a union combiner. Then this union configuration is
 * added to the resulting combined configuration under the name defined by the
 * {@code ADDITIONAL_NAME} constant. The {@link #getNamedBuilder(String)} method
 * can be used to access the {@code ConfigurationBuilder} objects for all
 * configuration sources which have been assigned a name; care has to be taken
 * that these names are unique.
 * &lt;/p&gt;
 *
 * @since 1.3
 * @author &lt;a
 *         href=&quot;http://commons.apache.org/configuration/team-list.html&quot;&gt;Commons
 *         Configuration team&lt;/a&gt;
 * @version $Id$
 */
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">public class CombinedConfigurationBuilder extends BasicConfigurationBuilder&lt;CombinedConfiguration&gt;</span>
{
    /**
     * Constant for the name of the additional configuration. If the
     * configuration definition file contains an {@code additional}
     * section, a special union configuration is created and added under this
     * name to the resulting combined configuration.
     */
<span class="fc" id="L248">    public static final String ADDITIONAL_NAME = CombinedConfigurationBuilder.class</span>
<span class="fc" id="L249">            .getName()</span>
            + &quot;/ADDITIONAL_CONFIG&quot;;

    /** Constant for the name of the configuration bean factory. */
<span class="fc" id="L253">    static final String CONFIG_BEAN_FACTORY_NAME = CombinedConfigurationBuilder.class</span>
<span class="fc" id="L254">            .getName()</span>
            + &quot;.CONFIG_BEAN_FACTORY_NAME&quot;;

    /** Constant for the reserved name attribute. */
    static final String ATTR_NAME = DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_START
            + XMLBeanDeclaration.RESERVED_PREFIX
            + &quot;name&quot;
            + DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_END;

    /** Constant for the name of the at attribute. */
    static final String ATTR_ATNAME = &quot;at&quot;;

    /** Constant for the reserved at attribute. */
    static final String ATTR_AT_RES = DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_START
            + XMLBeanDeclaration.RESERVED_PREFIX
            + ATTR_ATNAME
            + DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_END;

    /** Constant for the at attribute without the reserved prefix. */
    static final String ATTR_AT = DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_START
            + ATTR_ATNAME + DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_END;

    /** Constant for the name of the optional attribute. */
    static final String ATTR_OPTIONALNAME = &quot;optional&quot;;

    /** Constant for the reserved optional attribute. */
    static final String ATTR_OPTIONAL_RES = DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_START
            + XMLBeanDeclaration.RESERVED_PREFIX
            + ATTR_OPTIONALNAME
            + DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_END;

    /** Constant for the optional attribute without the reserved prefix. */
    static final String ATTR_OPTIONAL = DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_START
            + ATTR_OPTIONALNAME + DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_END;

    /** Constant for the forceCreate attribute. */
    static final String ATTR_FORCECREATE = DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_START
            + XMLBeanDeclaration.RESERVED_PREFIX
            + &quot;forceCreate&quot;
            + DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_END;

    /** Constant for the reload attribute. */
    static final String ATTR_RELOAD = DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_START
            + XMLBeanDeclaration.RESERVED_PREFIX
            + &quot;reload&quot;
            + DefaultExpressionEngineSymbols.DEFAULT_ATTRIBUTE_END;

    /**
     * Constant for the tag attribute for providers.
     */
    static final String KEY_SYSTEM_PROPS = &quot;[@systemProperties]&quot;;

    /** Constant for the name of the header section. */
    static final String SEC_HEADER = &quot;header&quot;;

    /** Constant for an expression that selects the union configurations. */
    static final String KEY_UNION = &quot;additional&quot;;

    /** An array with the names of top level configuration sections.*/
<span class="fc" id="L313">    static final String[] CONFIG_SECTIONS = {</span>
        &quot;additional&quot;, &quot;override&quot;, SEC_HEADER
    };

    /**
     * Constant for an expression that selects override configurations in the
     * override section.
     */
    static final String KEY_OVERRIDE = &quot;override&quot;;

    /**
     * Constant for the key that points to the list nodes definition of the
     * override combiner.
     */
    static final String KEY_OVERRIDE_LIST = SEC_HEADER
            + &quot;.combiner.override.list-nodes.node&quot;;

    /**
     * Constant for the key that points to the list nodes definition of the
     * additional combiner.
     */
    static final String KEY_ADDITIONAL_LIST = SEC_HEADER
            + &quot;.combiner.additional.list-nodes.node&quot;;

    /**
     * Constant for the key for defining providers in the configuration file.
     */
    static final String KEY_CONFIGURATION_PROVIDERS = SEC_HEADER
            + &quot;.providers.provider&quot;;

    /**
     * Constant for the tag attribute for providers.
     */
    static final String KEY_PROVIDER_KEY = XMLBeanDeclaration.ATTR_PREFIX + &quot;tag]&quot;;

    /**
     * Constant for the key for defining variable resolvers
     */
    static final String KEY_CONFIGURATION_LOOKUPS = SEC_HEADER
            + &quot;.lookups.lookup&quot;;

    /**
     * Constant for the key for defining entity resolvers
     */
    static final String KEY_ENTITY_RESOLVER = SEC_HEADER + &quot;.entity-resolver&quot;;

    /**
     * Constant for the prefix attribute for lookups.
     */
    static final String KEY_LOOKUP_KEY = XMLBeanDeclaration.ATTR_PREFIX + &quot;prefix]&quot;;

    /**
     * Constant for the FileSystem.
     */
    static final String FILE_SYSTEM = SEC_HEADER + &quot;.fileSystem&quot;;

    /**
     * Constant for the key of the result declaration. This key can point to a
     * bean declaration, which defines properties of the resulting combined
     * configuration.
     */
    static final String KEY_RESULT = SEC_HEADER + &quot;.result&quot;;

    /** Constant for the key of the combiner in the result declaration.*/
    static final String KEY_COMBINER = KEY_RESULT + &quot;.nodeCombiner&quot;;

    /** Constant for the XML file extension. */
    static final String EXT_XML = &quot;xml&quot;;

    /** Constant for the basic configuration builder class. */
    private static final String BASIC_BUILDER =
            &quot;org.apache.commons.configuration2.builder.BasicConfigurationBuilder&quot;;

    /** Constant for the file-based configuration builder class. */
    private static final String FILE_BUILDER =
            &quot;org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder&quot;;

    /** Constant for the reloading file-based configuration builder class. */
    private static final String RELOADING_BUILDER =
            &quot;org.apache.commons.configuration2.builder.ReloadingFileBasedConfigurationBuilder&quot;;

    /** Constant for the name of the file-based builder parameters class. */
    private static final String FILE_PARAMS =
            &quot;org.apache.commons.configuration2.builder.FileBasedBuilderParametersImpl&quot;;

    /** Constant for the provider for properties files. */
<span class="fc" id="L399">    private static final ConfigurationBuilderProvider PROPERTIES_PROVIDER =</span>
            new FileExtensionConfigurationBuilderProvider(
                    FILE_BUILDER,
                    RELOADING_BUILDER,
                    &quot;org.apache.commons.configuration2.XMLPropertiesConfiguration&quot;,
                    &quot;org.apache.commons.configuration2.PropertiesConfiguration&quot;,
<span class="fc" id="L405">                    EXT_XML, Collections.singletonList(FILE_PARAMS));</span>

    /** Constant for the provider for XML files. */
<span class="fc" id="L408">    private static final ConfigurationBuilderProvider XML_PROVIDER =</span>
            new BaseConfigurationBuilderProvider(FILE_BUILDER, RELOADING_BUILDER,
                    &quot;org.apache.commons.configuration2.XMLConfiguration&quot;,
<span class="fc" id="L411">                    Collections.singletonList(&quot;org.apache.commons.configuration2.builder.XMLBuilderParametersImpl&quot;));</span>

    /** Constant for the provider for JNDI sources. */
<span class="fc" id="L414">    private static final BaseConfigurationBuilderProvider JNDI_PROVIDER =</span>
            new BaseConfigurationBuilderProvider(
                    BASIC_BUILDER,
                    null,
                    &quot;org.apache.commons.configuration2.JNDIConfiguration&quot;,
<span class="fc" id="L419">                    Collections.singletonList(&quot;org.apache.commons.configuration2.builder.JndiBuilderParametersImpl&quot;));</span>

    /** Constant for the provider for system properties. */
<span class="fc" id="L422">    private static final BaseConfigurationBuilderProvider SYSTEM_PROVIDER =</span>
            new BaseConfigurationBuilderProvider(
                    BASIC_BUILDER,
                    null,
                    &quot;org.apache.commons.configuration2.SystemConfiguration&quot;,
<span class="fc" id="L427">                    Collections.singletonList(&quot;org.apache.commons.configuration2.builder.BasicBuilderParameters&quot;));</span>

    /** Constant for the provider for ini files. */
<span class="fc" id="L430">    private static final BaseConfigurationBuilderProvider INI_PROVIDER =</span>
            new BaseConfigurationBuilderProvider(FILE_BUILDER, RELOADING_BUILDER,
                    &quot;org.apache.commons.configuration2.INIConfiguration&quot;,
<span class="fc" id="L433">                    Collections.singletonList(FILE_PARAMS));</span>

    /** Constant for the provider for environment properties. */
<span class="fc" id="L436">    private static final BaseConfigurationBuilderProvider ENV_PROVIDER =</span>
            new BaseConfigurationBuilderProvider(
                    BASIC_BUILDER,
                    null,
                    &quot;org.apache.commons.configuration2.EnvironmentConfiguration&quot;,
<span class="fc" id="L441">                    Collections.singletonList(&quot;org.apache.commons.configuration2.builder.BasicBuilderParameters&quot;));</span>

    /** Constant for the provider for plist files. */
<span class="fc" id="L444">    private static final BaseConfigurationBuilderProvider PLIST_PROVIDER =</span>
            new FileExtensionConfigurationBuilderProvider(
                    FILE_BUILDER,
                    RELOADING_BUILDER,
                    &quot;org.apache.commons.configuration2.plist.XMLPropertyListConfiguration&quot;,
                    &quot;org.apache.commons.configuration2.plist.PropertyListConfiguration&quot;,
<span class="fc" id="L450">                    EXT_XML, Collections.singletonList(FILE_PARAMS));</span>

    /** Constant for the provider for configuration definition files. */
<span class="fc" id="L453">    private static final BaseConfigurationBuilderProvider COMBINED_PROVIDER =</span>
            new CombinedConfigurationBuilderProvider();

    /** Constant for the provider for multiple XML configurations. */
<span class="fc" id="L457">    private static final MultiFileConfigurationBuilderProvider MULTI_XML_PROVIDER =</span>
            new MultiFileConfigurationBuilderProvider(
                    &quot;org.apache.commons.configuration2.XMLConfiguration&quot;,
                    &quot;org.apache.commons.configuration2.builder.XMLBuilderParametersImpl&quot;);

    /** An array with the names of the default tags. */
<span class="fc" id="L463">    private static final String[] DEFAULT_TAGS = {</span>
            &quot;properties&quot;, &quot;xml&quot;, &quot;hierarchicalXml&quot;, &quot;plist&quot;,
            &quot;ini&quot;, &quot;system&quot;, &quot;env&quot;, &quot;jndi&quot;, &quot;configuration&quot;, &quot;multiFile&quot;
    };

    /** An array with the providers for the default tags. */
<span class="fc" id="L469">    private static final ConfigurationBuilderProvider[] DEFAULT_PROVIDERS = {</span>
            PROPERTIES_PROVIDER, XML_PROVIDER, XML_PROVIDER, PLIST_PROVIDER, INI_PROVIDER,
            SYSTEM_PROVIDER, ENV_PROVIDER, JNDI_PROVIDER, COMBINED_PROVIDER,
            MULTI_XML_PROVIDER
    };

    /** A map with the default configuration builder providers. */
    private static final Map&lt;String, ConfigurationBuilderProvider&gt; DEFAULT_PROVIDERS_MAP;

    /** The builder for the definition configuration. */
    private ConfigurationBuilder&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; definitionBuilder;

    /** Stores temporarily the configuration with the builder definitions. */
    private HierarchicalConfiguration&lt;?&gt; definitionConfiguration;

    /** The object with data about configuration sources. */
    private ConfigurationSourceData sourceData;

    /** Stores the current parameters object. */
    private CombinedBuilderParametersImpl currentParameters;

    /** The current XML parameters object. */
    private XMLBuilderParametersImpl currentXMLParameters;

    /** The configuration that is currently constructed. */
    private CombinedConfiguration currentConfiguration;

    /**
     * A {@code ConfigurationInterpolator} to be used as parent for all child
     * configurations to enable cross-source interpolation.
     */
    private ConfigurationInterpolator parentInterpolator;

    /**
     * Creates a new instance of {@code CombinedConfigurationBuilder}. No parameters
     * are set.
     */
    public CombinedConfigurationBuilder()
    {
<span class="fc" id="L508">        super(CombinedConfiguration.class);</span>
<span class="fc" id="L509">    }</span>

    /**
     *
     * Creates a new instance of {@code CombinedConfigurationBuilder} and sets
     * the specified initialization parameters.
     * @param params a map with initialization parameters
     */
    public CombinedConfigurationBuilder(final Map&lt;String, Object&gt; params)
    {
<span class="fc" id="L519">        super(CombinedConfiguration.class, params);</span>
<span class="fc" id="L520">    }</span>

    /**
     *
     * Creates a new instance of {@code CombinedConfigurationBuilder} and sets
     * the specified initialization parameters and the &lt;em&gt;allowFailOnInit&lt;/em&gt; flag.
     * @param params a map with initialization parameters
     * @param allowFailOnInit the &lt;em&gt;allowFailOnInit&lt;/em&gt; flag
     */
    public CombinedConfigurationBuilder(final Map&lt;String, Object&gt; params, final boolean allowFailOnInit)
    {
<span class="fc" id="L531">        super(CombinedConfiguration.class, params, allowFailOnInit);</span>
<span class="fc" id="L532">    }</span>

    /**
     * Returns the {@code ConfigurationBuilder} which creates the definition
     * configuration.
     *
     * @return the builder for the definition configuration
     * @throws ConfigurationException if an error occurs
     */
    public synchronized ConfigurationBuilder&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; getDefinitionBuilder()
            throws ConfigurationException
    {
<span class="fc bfc" id="L544" title="All 2 branches covered.">        if (definitionBuilder == null)</span>
        {
<span class="fc" id="L546">            definitionBuilder = setupDefinitionBuilder(getParameters());</span>
<span class="fc" id="L547">            addDefinitionBuilderChangeListener(definitionBuilder);</span>
        }
<span class="fc" id="L549">        return definitionBuilder;</span>
    }

    /**
     * {@inheritDoc} This method is overridden to adapt the return type.
     */
    @Override
    public CombinedConfigurationBuilder configure(final BuilderParameters... params)
    {
<span class="fc" id="L558">        super.configure(params);</span>
<span class="fc" id="L559">        return this;</span>
    }

    /**
     * &lt;p&gt;
     * Returns the configuration builder with the given name. With this method a
     * builder of a child configuration which was given a name in the
     * configuration definition file can be accessed directly.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Important note:&lt;/strong&gt; This method only returns a meaningful
     * result after the result configuration has been created by calling
     * {@code getConfiguration()}. If called before, always an exception is
     * thrown.
     * &lt;/p&gt;
     *
     * @param name the name of the builder in question
     * @return the child configuration builder with this name
     * @throws ConfigurationException if information about named builders is not
     *         yet available or no builder with this name exists
     */
    public synchronized ConfigurationBuilder&lt;? extends Configuration&gt; getNamedBuilder(
            final String name) throws ConfigurationException
    {
<span class="fc bfc" id="L583" title="All 2 branches covered.">        if (sourceData == null)</span>
        {
<span class="fc" id="L585">            throw new ConfigurationException(&quot;Information about child builders&quot;</span>
                    + &quot; has not been setup yet! Call getConfiguration() first.&quot;);
        }
<span class="fc" id="L588">        final ConfigurationBuilder&lt;? extends Configuration&gt; builder =</span>
<span class="fc" id="L589">                sourceData.getNamedBuilder(name);</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">        if (builder == null)</span>
        {
<span class="fc" id="L592">            throw new ConfigurationException(&quot;Builder cannot be resolved: &quot;</span>
                    + name);
        }
<span class="fc" id="L595">        return builder;</span>
    }

    /**
     * &lt;p&gt;
     * Returns a set with the names of all child configuration builders. A tag
     * defining a configuration source in the configuration definition file can
     * have the {@code config-name} attribute. If this attribute is present, the
     * corresponding builder is assigned this name and can be directly accessed
     * through the {@link #getNamedBuilder(String)} method. This method returns
     * a collection with all available builder names.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Important note:&lt;/strong&gt; This method only returns a meaningful
     * result after the result configuration has been created by calling
     * {@code getConfiguration()}. If called before, always an empty set is
     * returned.
     * &lt;/p&gt;
     *
     * @return a set with the names of all builders
     */
    public synchronized Set&lt;String&gt; builderNames()
    {
<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (sourceData == null)</span>
        {
<span class="fc" id="L620">            return Collections.emptySet();</span>
        }
<span class="fc" id="L622">        return Collections.unmodifiableSet(sourceData.builderNames());</span>
    }

    /**
     * {@inheritDoc} This implementation resets some specific internal state of
     * this builder.
     */
    @Override
    public synchronized void resetParameters()
    {
<span class="fc" id="L632">        super.resetParameters();</span>
<span class="fc" id="L633">        definitionBuilder = null;</span>
<span class="fc" id="L634">        definitionConfiguration = null;</span>
<span class="fc" id="L635">        currentParameters = null;</span>
<span class="fc" id="L636">        currentXMLParameters = null;</span>

<span class="pc bpc" id="L638" title="1 of 2 branches missed.">        if (sourceData != null)</span>
        {
<span class="fc" id="L640">            sourceData.cleanUp();</span>
<span class="fc" id="L641">            sourceData = null;</span>
        }
<span class="fc" id="L643">    }</span>

    /**
     * Obtains the {@code ConfigurationBuilder} object which provides access to
     * the configuration containing the definition of the combined configuration
     * to create. If a definition builder is defined in the parameters, it is
     * used. Otherwise, we check whether the combined builder parameters object
     * contains a parameters object for the definition builder. If this is the
     * case, a builder for an {@code XMLConfiguration} is created and configured
     * with this object. As a last resort, it is looked for a
     * {@link FileBasedBuilderParametersImpl} object in the properties. If
     * found, also a XML configuration builder is created which loads this file.
     * Note: This method is called from a synchronized block.
     *
     * @param params the current parameters for this builder
     * @return the builder for the definition configuration
     * @throws ConfigurationException if an error occurs
     */
    protected ConfigurationBuilder&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; setupDefinitionBuilder(
            final Map&lt;String, Object&gt; params) throws ConfigurationException
    {
<span class="fc" id="L664">        final CombinedBuilderParametersImpl cbParams =</span>
<span class="fc" id="L665">                CombinedBuilderParametersImpl.fromParameters(params);</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">        if (cbParams != null)</span>
        {
<span class="fc" id="L668">            final ConfigurationBuilder&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; defBuilder =</span>
<span class="fc" id="L669">                    cbParams.getDefinitionBuilder();</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (defBuilder != null)</span>
            {
<span class="fc" id="L672">                return defBuilder;</span>
            }

<span class="fc bfc" id="L675" title="All 2 branches covered.">            if (cbParams.getDefinitionBuilderParameters() != null)</span>
            {
<span class="fc" id="L677">                return createXMLDefinitionBuilder(cbParams</span>
<span class="fc" id="L678">                        .getDefinitionBuilderParameters());</span>
            }
        }

<span class="fc" id="L682">        final BuilderParameters fileParams =</span>
<span class="fc" id="L683">                FileBasedBuilderParametersImpl.fromParameters(params);</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">        if (fileParams != null)</span>
        {
<span class="fc" id="L686">            return createXMLDefinitionBuilder(fileParams);</span>
        }

<span class="fc" id="L689">        throw new ConfigurationException(</span>
                &quot;No builder for configuration definition specified!&quot;);
    }

    /**
     * Creates a default builder for the definition configuration and
     * initializes it with a parameters object. This method is called if no
     * definition builder is defined in this builder's parameters. This
     * implementation creates a default file-based builder which produces an
     * {@code XMLConfiguration}; it expects a corresponding file specification.
     * Note: This method is called in a synchronized block.
     *
     * @param builderParams the parameters object for the builder
     * @return the standard builder for the definition configuration
     */
    protected ConfigurationBuilder&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; createXMLDefinitionBuilder(
            final BuilderParameters builderParams)
    {
<span class="fc" id="L707">        return new FileBasedConfigurationBuilder&lt;&gt;(</span>
<span class="fc" id="L708">                XMLConfiguration.class).configure(builderParams);</span>
    }

    /**
     * Returns the configuration containing the definition of the combined
     * configuration to be created. This method only returns a defined result
     * during construction of the result configuration. The definition
     * configuration is obtained from the definition builder at first access and
     * then stored temporarily to ensure that during result construction always
     * the same configuration instance is used. (Otherwise, it would be possible
     * that the definition builder returns a different instance when queried
     * multiple times.)
     *
     * @return the definition configuration
     * @throws ConfigurationException if an error occurs
     */
    protected HierarchicalConfiguration&lt;?&gt; getDefinitionConfiguration()
            throws ConfigurationException
    {
<span class="fc bfc" id="L727" title="All 2 branches covered.">        if (definitionConfiguration == null)</span>
        {
<span class="fc" id="L729">            definitionConfiguration = getDefinitionBuilder().getConfiguration();</span>
        }
<span class="fc" id="L731">        return definitionConfiguration;</span>
    }

    /**
     * Returns a collection with the builders for all child configuration
     * sources. This method can be used by derived classes providing additional
     * functionality on top of the declared configuration sources. It only
     * returns a defined value during construction of the result configuration
     * instance.
     *
     * @return a collection with the builders for child configuration sources
     */
    protected synchronized Collection&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; getChildBuilders()
    {
<span class="fc" id="L745">        return sourceData.getChildBuilders();</span>
    }

    /**
     * {@inheritDoc} This implementation evaluates the {@code result} property
     * of the definition configuration. It creates a combined bean declaration
     * with both the properties specified in the definition file and the
     * properties defined as initialization parameters.
     */
    @Override
    protected BeanDeclaration createResultDeclaration(final Map&lt;String, Object&gt; params)
            throws ConfigurationException
    {
<span class="fc" id="L758">        final BeanDeclaration paramsDecl = super.createResultDeclaration(params);</span>
<span class="fc" id="L759">        final XMLBeanDeclaration resultDecl =</span>
<span class="fc" id="L760">                new XMLBeanDeclaration(getDefinitionConfiguration(),</span>
<span class="fc" id="L761">                        KEY_RESULT, true, CombinedConfiguration.class.getName());</span>
<span class="fc" id="L762">        return new CombinedBeanDeclaration(resultDecl, paramsDecl);</span>
    }

    /**
     * {@inheritDoc} This implementation processes the definition configuration
     * in order to
     * &lt;ul&gt;
     * &lt;li&gt;initialize the resulting {@code CombinedConfiguration}&lt;/li&gt;
     * &lt;li&gt;determine the builders for all configuration sources&lt;/li&gt;
     * &lt;li&gt;populate the resulting {@code CombinedConfiguration}&lt;/li&gt;
     * &lt;/ul&gt;
     */
    @Override
    protected void initResultInstance(final CombinedConfiguration result)
            throws ConfigurationException
    {
<span class="fc" id="L778">        super.initResultInstance(result);</span>

<span class="fc" id="L780">        currentConfiguration = result;</span>
<span class="fc" id="L781">        final HierarchicalConfiguration&lt;?&gt; config = getDefinitionConfiguration();</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">        if (config.getMaxIndex(KEY_COMBINER) &lt; 0)</span>
        {
            // No combiner defined =&gt; set default
<span class="fc" id="L785">            result.setNodeCombiner(new OverrideCombiner());</span>
        }

<span class="fc" id="L788">        setUpCurrentParameters();</span>
<span class="fc" id="L789">        initNodeCombinerListNodes(result, config, KEY_OVERRIDE_LIST);</span>
<span class="fc" id="L790">        registerConfiguredProviders(config);</span>
<span class="fc" id="L791">        setUpCurrentXMLParameters();</span>
<span class="fc" id="L792">        currentXMLParameters.setFileSystem(initFileSystem(config));</span>
<span class="fc" id="L793">        initSystemProperties(config, getBasePath());</span>
<span class="fc" id="L794">        registerConfiguredLookups(config, result);</span>
<span class="fc" id="L795">        configureEntityResolver(config, currentXMLParameters);</span>
<span class="fc" id="L796">        setUpParentInterpolator(currentConfiguration, config);</span>

<span class="fc" id="L798">        final ConfigurationSourceData data = getSourceData();</span>
<span class="fc" id="L799">        final boolean createBuilders = data.getChildBuilders().isEmpty();</span>
<span class="fc" id="L800">        final List&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; overrideBuilders =</span>
<span class="fc" id="L801">                data.createAndAddConfigurations(result,</span>
<span class="fc" id="L802">                        data.getOverrideSources(), data.overrideBuilders);</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">        if (createBuilders)</span>
        {
<span class="fc" id="L805">            data.overrideBuilders.addAll(overrideBuilders);</span>
        }
<span class="fc bfc" id="L807" title="All 2 branches covered.">        if (!data.getUnionSources().isEmpty())</span>
        {
<span class="fc" id="L809">            final CombinedConfiguration addConfig = createAdditionalsConfiguration(result);</span>
<span class="fc" id="L810">            result.addConfiguration(addConfig, ADDITIONAL_NAME);</span>
<span class="fc" id="L811">            initNodeCombinerListNodes(addConfig, config, KEY_ADDITIONAL_LIST);</span>
<span class="fc" id="L812">            final List&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; unionBuilders =</span>
<span class="fc" id="L813">                    data.createAndAddConfigurations(addConfig,</span>
<span class="fc" id="L814">                            data.unionDeclarations, data.unionBuilders);</span>
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">            if (createBuilders)</span>
            {
<span class="fc" id="L817">                data.unionBuilders.addAll(unionBuilders);</span>
            }
        }

<span class="fc" id="L821">        result.isEmpty();  // this sets up the node structure</span>
<span class="fc" id="L822">        currentConfiguration = null;</span>
<span class="fc" id="L823">    }</span>

    /**
     * Creates the {@code CombinedConfiguration} for the configuration
     * sources in the &lt;code&gt;&amp;lt;additional&amp;gt;&lt;/code&gt; section. This method is
     * called when the builder constructs the final configuration. It creates a
     * new {@code CombinedConfiguration} and initializes some properties
     * from the result configuration.
     *
     * @param resultConfig the result configuration (this is the configuration
     *        that will be returned by the builder)
     * @return the {@code CombinedConfiguration} for the additional
     *         configuration sources
     * @since 1.7
     */
    protected CombinedConfiguration createAdditionalsConfiguration(
            final CombinedConfiguration resultConfig)
    {
<span class="fc" id="L841">        final CombinedConfiguration addConfig =</span>
                new CombinedConfiguration(new UnionCombiner());
<span class="fc" id="L843">        addConfig.setListDelimiterHandler(resultConfig.getListDelimiterHandler());</span>
<span class="fc" id="L844">        return addConfig;</span>
    }

    /**
     * Processes custom {@link Lookup} objects that might be declared in the
     * definition configuration. Each {@code Lookup} object is registered at the
     * definition configuration and at the result configuration. It is also
     * added to all child configurations added to the resulting combined
     * configuration.
     *
     * @param defConfig the definition configuration
     * @param resultConfig the resulting configuration
     * @throws ConfigurationException if an error occurs
     */
    protected void registerConfiguredLookups(
            final HierarchicalConfiguration&lt;?&gt; defConfig, final Configuration resultConfig)
            throws ConfigurationException
    {
<span class="fc" id="L862">        final Map&lt;String, Lookup&gt; lookups = new HashMap&lt;&gt;();</span>

<span class="fc" id="L864">        final List&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; nodes =</span>
<span class="fc" id="L865">                defConfig.configurationsAt(KEY_CONFIGURATION_LOOKUPS);</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">        for (final HierarchicalConfiguration&lt;?&gt; config : nodes)</span>
        {
<span class="fc" id="L868">            final XMLBeanDeclaration decl = new XMLBeanDeclaration(config);</span>
<span class="fc" id="L869">            final String key = config.getString(KEY_LOOKUP_KEY);</span>
<span class="fc" id="L870">            final Lookup lookup = (Lookup) fetchBeanHelper().createBean(decl);</span>
<span class="fc" id="L871">            lookups.put(key, lookup);</span>
<span class="fc" id="L872">        }</span>

<span class="fc bfc" id="L874" title="All 2 branches covered.">        if (!lookups.isEmpty())</span>
        {
<span class="fc" id="L876">            final ConfigurationInterpolator defCI = defConfig.getInterpolator();</span>
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">            if (defCI != null)</span>
            {
<span class="fc" id="L879">                defCI.registerLookups(lookups);</span>
            }
<span class="fc" id="L881">            resultConfig.getInterpolator().registerLookups(lookups);</span>
        }
<span class="fc" id="L883">    }</span>

    /**
     * Creates and initializes a default {@code FileSystem} if the definition
     * configuration contains a corresponding declaration. The file system
     * returned by this method is used as default for all file-based child
     * configuration sources.
     *
     * @param config the definition configuration
     * @return the default {@code FileSystem} (may be &lt;b&gt;null&lt;/b&gt;)
     * @throws ConfigurationException if an error occurs
     */
    protected FileSystem initFileSystem(final HierarchicalConfiguration&lt;?&gt; config)
            throws ConfigurationException
    {
<span class="fc bfc" id="L898" title="All 2 branches covered.">        if (config.getMaxIndex(FILE_SYSTEM) == 0)</span>
        {
<span class="fc" id="L900">            final XMLBeanDeclaration decl =</span>
                    new XMLBeanDeclaration(config, FILE_SYSTEM);
<span class="fc" id="L902">            return (FileSystem) fetchBeanHelper().createBean(decl);</span>
        }
<span class="fc" id="L904">        return null;</span>
    }

    /**
     * Handles a file with system properties that may be defined in the
     * definition configuration. If such property file is configured, all of its
     * properties are added to the system properties.
     *
     * @param config the definition configuration
     * @param basePath the base path defined for this builder (may be
     *        &lt;b&gt;null&lt;/b&gt;)
     * @throws ConfigurationException if an error occurs.
     */
    protected void initSystemProperties(final HierarchicalConfiguration&lt;?&gt; config,
            final String basePath) throws ConfigurationException
    {
<span class="fc" id="L920">        final String fileName = config.getString(KEY_SYSTEM_PROPS);</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">        if (fileName != null)</span>
        {
            try
            {
<span class="fc" id="L925">                SystemConfiguration.setSystemProperties(basePath, fileName);</span>
            }
<span class="nc" id="L927">            catch (final Exception ex)</span>
            {
<span class="nc" id="L929">                throw new ConfigurationException(</span>
                        &quot;Error setting system properties from &quot; + fileName, ex);
<span class="fc" id="L931">            }</span>
        }
<span class="fc" id="L933">    }</span>

    /**
     * Creates and initializes a default {@code EntityResolver} if the
     * definition configuration contains a corresponding declaration.
     *
     * @param config the definition configuration
     * @param xmlParams the (already partly initialized) object with XML
     *        parameters; here the new resolver is to be stored
     * @throws ConfigurationException if an error occurs
     */
    protected void configureEntityResolver(final HierarchicalConfiguration&lt;?&gt; config,
            final XMLBuilderParametersImpl xmlParams) throws ConfigurationException
    {
<span class="fc bfc" id="L947" title="All 2 branches covered.">        if (config.getMaxIndex(KEY_ENTITY_RESOLVER) == 0)</span>
        {
<span class="fc" id="L949">            final XMLBeanDeclaration decl =</span>
                    new XMLBeanDeclaration(config, KEY_ENTITY_RESOLVER, true);
<span class="fc" id="L951">            final EntityResolver resolver =</span>
<span class="fc" id="L952">                    (EntityResolver) fetchBeanHelper().createBean(decl,</span>
                            CatalogResolver.class);
<span class="fc" id="L954">            final FileSystem fileSystem = xmlParams.getFileHandler().getFileSystem();</span>
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">            if (fileSystem != null)</span>
            {
<span class="fc" id="L957">                BeanHelper.setProperty(resolver, &quot;fileSystem&quot;, fileSystem);</span>
            }
<span class="fc" id="L959">            final String basePath = xmlParams.getFileHandler().getBasePath();</span>
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">            if (basePath != null)</span>
            {
<span class="fc" id="L962">                BeanHelper.setProperty(resolver, &quot;baseDir&quot;, basePath);</span>
            }
<span class="fc" id="L964">            final ConfigurationInterpolator ci = new ConfigurationInterpolator();</span>
<span class="fc" id="L965">            ci.registerLookups(fetchPrefixLookups());</span>
<span class="fc" id="L966">            BeanHelper.setProperty(resolver, &quot;interpolator&quot;, ci);</span>

<span class="fc" id="L968">            xmlParams.setEntityResolver(resolver);</span>
        }
<span class="fc" id="L970">    }</span>

    /**
     * Returns the {@code ConfigurationBuilderProvider} for the given tag. This
     * method is called during creation of the result configuration. (It is not
     * allowed to call it at another point of time; result is then
     * unpredictable!) It supports all default providers and custom providers
     * added through the parameters object as well.
     *
     * @param tagName the name of the tag
     * @return the provider that was registered for this tag or &lt;b&gt;null&lt;/b&gt; if
     *         there is none
     */
    protected ConfigurationBuilderProvider providerForTag(final String tagName)
    {
<span class="fc" id="L985">        return currentParameters.providerForTag(tagName);</span>
    }

    /**
     * Initializes a parameters object for a child builder. This combined
     * configuration builder has a bunch of properties which may be inherited by
     * child configurations, e.g. the base path, the file system, etc. While
     * processing the builders for child configurations, this method is called
     * for each parameters object for a child builder. It initializes some
     * properties of the passed in parameters objects which are derived from
     * this parent builder.
     *
     * @param params the parameters object to be initialized
     */
    protected void initChildBuilderParameters(final BuilderParameters params)
    {
<span class="fc" id="L1001">        initDefaultChildParameters(params);</span>

<span class="pc bpc" id="L1003" title="1 of 2 branches missed.">        if (params instanceof BasicBuilderParameters)</span>
        {
<span class="fc" id="L1005">            initChildBasicParameters((BasicBuilderParameters) params);</span>
        }
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        if (params instanceof XMLBuilderProperties&lt;?&gt;)</span>
        {
<span class="fc" id="L1009">            initChildXMLParameters((XMLBuilderProperties&lt;?&gt;) params);</span>
        }
<span class="fc bfc" id="L1011" title="All 2 branches covered.">        if (params instanceof FileBasedBuilderProperties&lt;?&gt;)</span>
        {
<span class="fc" id="L1013">            initChildFileBasedParameters((FileBasedBuilderProperties&lt;?&gt;) params);</span>
        }
<span class="fc bfc" id="L1015" title="All 2 branches covered.">        if (params instanceof CombinedBuilderParametersImpl)</span>
        {
<span class="fc" id="L1017">            initChildCombinedParameters((CombinedBuilderParametersImpl) params);</span>
        }
<span class="fc" id="L1019">    }</span>

    /**
     * Initializes the event listeners of the specified builder from this
     * object. This method is used to inherit all listeners from a parent
     * builder.
     *
     * @param dest the destination builder object which is to be initialized
     */
    void initChildEventListeners(
            final BasicConfigurationBuilder&lt;? extends Configuration&gt; dest)
    {
<span class="fc" id="L1031">        copyEventListeners(dest);</span>
<span class="fc" id="L1032">    }</span>

    /**
     * Returns the configuration object that is currently constructed. This
     * method can be called during construction of the result configuration. It
     * is intended for internal usage, e.g. some specialized builder providers
     * need access to this configuration to perform advanced initialization.
     *
     * @return the configuration that us currently under construction
     */
    CombinedConfiguration getConfigurationUnderConstruction()
    {
<span class="fc" id="L1044">        return currentConfiguration;</span>
    }

    /**
     * Initializes a bean using the current {@code BeanHelper}. This is needed
     * by builder providers when the configuration objects for sub builders are
     * constructed.
     *
     * @param bean the bean to be initialized
     * @param decl the {@code BeanDeclaration}
     */
    void initBean(final Object bean, final BeanDeclaration decl)
    {
<span class="fc" id="L1057">        fetchBeanHelper().initBean(bean, decl);</span>
<span class="fc" id="L1058">    }</span>

    /**
     * Initializes the current parameters object. This object has either been
     * passed at builder configuration time or it is newly created. In any
     * case, it is manipulated during result creation.
     */
    private void setUpCurrentParameters()
    {
<span class="fc" id="L1067">        currentParameters =</span>
<span class="fc" id="L1068">                CombinedBuilderParametersImpl.fromParameters(getParameters(), true);</span>
<span class="fc" id="L1069">        currentParameters.registerMissingProviders(DEFAULT_PROVIDERS_MAP);</span>
<span class="fc" id="L1070">    }</span>

    /**
     * Sets up an XML parameters object which is used to store properties
     * related to XML and file-based configurations during creation of the
     * result configuration. The properties stored in this object can be
     * inherited to child configurations.
     *
     * @throws ConfigurationException if an error occurs
     */
    private void setUpCurrentXMLParameters() throws ConfigurationException
    {
<span class="fc" id="L1082">        currentXMLParameters = new XMLBuilderParametersImpl();</span>
<span class="fc" id="L1083">        initDefaultBasePath();</span>
<span class="fc" id="L1084">    }</span>

    /**
     * Sets up a parent {@code ConfigurationInterpolator} object. This object
     * has a default {@link Lookup} querying the resulting combined
     * configuration. Thus interpolation works globally across all configuration
     * sources.
     *
     * @param resultConfig the result configuration
     * @param defConfig the definition configuration
     */
    private void setUpParentInterpolator(final Configuration resultConfig,
            final Configuration defConfig)
    {
<span class="fc" id="L1098">        parentInterpolator = new ConfigurationInterpolator();</span>
<span class="fc" id="L1099">        parentInterpolator.addDefaultLookup(new ConfigurationLookup(</span>
                resultConfig));
<span class="fc" id="L1101">        final ConfigurationInterpolator defInterpolator = defConfig.getInterpolator();</span>
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">        if (defInterpolator != null)</span>
        {
<span class="fc" id="L1104">            defInterpolator.setParentInterpolator(parentInterpolator);</span>
        }
<span class="fc" id="L1106">    }</span>

    /**
     * Initializes the default base path for all file-based child configuration
     * sources. The base path can be explicitly defined in the parameters of
     * this builder. Otherwise, if the definition builder is a file-based
     * builder, it is obtained from there.
     *
     * @throws ConfigurationException if an error occurs
     */
    private void initDefaultBasePath() throws ConfigurationException
    {
<span class="pc bpc" id="L1118" title="2 of 4 branches missed.">        assert currentParameters != null : &quot;Current parameters undefined!&quot;;</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">        if (currentParameters.getBasePath() != null)</span>
        {
<span class="fc" id="L1121">            currentXMLParameters.setBasePath(currentParameters.getBasePath());</span>
        }
        else
        {
<span class="fc" id="L1125">            final ConfigurationBuilder&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; defBuilder =</span>
<span class="fc" id="L1126">                    getDefinitionBuilder();</span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">            if (defBuilder instanceof FileBasedConfigurationBuilder)</span>
            {
                @SuppressWarnings(&quot;rawtypes&quot;)
                final
<span class="fc" id="L1131">                FileBasedConfigurationBuilder fileBuilder =</span>
                        (FileBasedConfigurationBuilder) defBuilder;
<span class="fc" id="L1133">                final URL url = fileBuilder.getFileHandler().getURL();</span>
<span class="fc bfc" id="L1134" title="All 2 branches covered.">                currentXMLParameters.setBasePath((url != null) ? url</span>
<span class="fc" id="L1135">                        .toExternalForm() : fileBuilder.getFileHandler()</span>
<span class="fc" id="L1136">                        .getBasePath());</span>
            }
        }
<span class="fc" id="L1139">    }</span>

    /**
     * Executes the {@link org.apache.commons.configuration2.builder.DefaultParametersManager
     * DefaultParametersManager} stored in the current
     * parameters on the passed in parameters object. If default handlers have been
     * registered for this type of parameters, an initialization is now
     * performed. This method is called before the parameters object is
     * initialized from the configuration definition file. So default values
     * can be overridden later with concrete property definitions.
     *
     * @param params the parameters to be initialized
     * @throws org.apache.commons.configuration2.ex.ConfigurationRuntimeException if an error
     *         occurs when copying properties
     */
    private void initDefaultChildParameters(final BuilderParameters params)
    {
<span class="fc" id="L1156">        currentParameters.getChildDefaultParametersManager()</span>
<span class="fc" id="L1157">                .initializeParameters(params);</span>
<span class="fc" id="L1158">    }</span>

    /**
     * Initializes basic builder parameters for a child configuration with
     * default settings set for this builder. This implementation ensures that
     * all {@code Lookup} objects are propagated to child configurations and
     * interpolation is setup correctly.
     *
     * @param params the parameters object
     */
    private void initChildBasicParameters(final BasicBuilderParameters params)
    {
<span class="fc" id="L1170">        params.setPrefixLookups(fetchPrefixLookups());</span>
<span class="fc" id="L1171">        params.setParentInterpolator(parentInterpolator);</span>
<span class="fc bfc" id="L1172" title="All 2 branches covered.">        if (currentParameters.isInheritSettings())</span>
        {
<span class="fc" id="L1174">            params.inheritFrom(getParameters());</span>
        }
<span class="fc" id="L1176">    }</span>

    /**
     * Initializes a parameters object for a file-based configuration with
     * properties already set for this parent builder. This method handles
     * properties like a default file system or a base path.
     *
     * @param params the parameters object
     */
    private void initChildFileBasedParameters(
            final FileBasedBuilderProperties&lt;?&gt; params)
    {
<span class="fc" id="L1188">        params.setBasePath(getBasePath());</span>
<span class="fc" id="L1189">        params.setFileSystem(currentXMLParameters.getFileHandler()</span>
<span class="fc" id="L1190">                .getFileSystem());</span>
<span class="fc" id="L1191">    }</span>

    /**
     * Initializes a parameters object for an XML configuration with properties
     * already set for this parent builder.
     *
     * @param params the parameters object
     */
    private void initChildXMLParameters(final XMLBuilderProperties&lt;?&gt; params)
    {
<span class="fc" id="L1201">        params.setEntityResolver(currentXMLParameters.getEntityResolver());</span>
<span class="fc" id="L1202">    }</span>

    /**
     * Initializes a parameters object for a combined configuration builder with
     * properties already set for this parent builder. This implementation deals
     * only with a subset of properties. Other properties are already handled by
     * the specialized builder provider.
     *
     * @param params the parameters object
     */
    private void initChildCombinedParameters(
            final CombinedBuilderParametersImpl params)
    {
<span class="fc" id="L1215">        params.registerMissingProviders(currentParameters);</span>
<span class="fc" id="L1216">        params.setBasePath(getBasePath());</span>
<span class="fc" id="L1217">    }</span>

    /**
     * Obtains the data object for the configuration sources and the
     * corresponding builders. This object is created on first access and reset
     * when the definition builder sends a change event. This method is called
     * in a synchronized block.
     *
     * @return the object with information about configuration sources
     * @throws ConfigurationException if an error occurs
     */
    private ConfigurationSourceData getSourceData()
            throws ConfigurationException
    {
<span class="fc bfc" id="L1231" title="All 2 branches covered.">        if (sourceData == null)</span>
        {
<span class="pc bpc" id="L1233" title="1 of 2 branches missed.">            if (currentParameters == null)</span>
            {
<span class="nc" id="L1235">                setUpCurrentParameters();</span>
<span class="nc" id="L1236">                setUpCurrentXMLParameters();</span>
            }
<span class="fc" id="L1238">            sourceData = createSourceData();</span>
        }
<span class="fc" id="L1240">        return sourceData;</span>
    }

    /**
     * Creates the data object for configuration sources and the corresponding
     * builders.
     *
     * @return the newly created data object
     * @throws ConfigurationException if an error occurs
     */
    private ConfigurationSourceData createSourceData()
            throws ConfigurationException
    {
<span class="fc" id="L1253">        final ConfigurationSourceData result = new ConfigurationSourceData();</span>
<span class="fc" id="L1254">        result.initFromDefinitionConfiguration(getDefinitionConfiguration());</span>
<span class="fc" id="L1255">        return result;</span>
    }

    /**
     * Returns the current base path of this configuration builder. This is used
     * for instance by all file-based child configurations.
     *
     * @return the base path
     */
    private String getBasePath()
    {
<span class="fc" id="L1266">        return currentXMLParameters.getFileHandler().getBasePath();</span>
    }

    /**
     * Registers providers defined in the configuration.
     *
     * @param defConfig the definition configuration
     * @throws ConfigurationException if an error occurs
     */
    private void registerConfiguredProviders(final HierarchicalConfiguration&lt;?&gt; defConfig)
            throws ConfigurationException
    {
<span class="fc" id="L1278">        final List&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; nodes =</span>
<span class="fc" id="L1279">                defConfig.configurationsAt(KEY_CONFIGURATION_PROVIDERS);</span>
<span class="fc bfc" id="L1280" title="All 2 branches covered.">        for (final HierarchicalConfiguration&lt;?&gt; config : nodes)</span>
        {
<span class="fc" id="L1282">            final XMLBeanDeclaration decl = new XMLBeanDeclaration(config);</span>
<span class="fc" id="L1283">            final String key = config.getString(KEY_PROVIDER_KEY);</span>
<span class="fc" id="L1284">            currentParameters.registerProvider(key,</span>
<span class="fc" id="L1285">                    (ConfigurationBuilderProvider) fetchBeanHelper().createBean(decl));</span>
<span class="fc" id="L1286">        }</span>
<span class="fc" id="L1287">    }</span>

    /**
     * Adds a listener at the given definition builder which resets this builder
     * when a reset of the definition builder happens. This way it is ensured
     * that this builder produces a new combined configuration when its
     * definition configuration changes.
     *
     * @param defBuilder the definition builder
     */
    private void addDefinitionBuilderChangeListener(
            final ConfigurationBuilder&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; defBuilder)
    {
<span class="fc" id="L1300">        defBuilder.addEventListener(ConfigurationBuilderEvent.RESET,</span>
                new EventListener&lt;ConfigurationBuilderEvent&gt;()
<span class="fc" id="L1302">                {</span>
            @Override
            public void onEvent(final ConfigurationBuilderEvent event)
            {
<span class="fc" id="L1306">                synchronized (CombinedConfigurationBuilder.this)</span>
                {
<span class="fc" id="L1308">                    reset();</span>
<span class="fc" id="L1309">                    definitionBuilder = defBuilder;</span>
<span class="fc" id="L1310">                }</span>
<span class="fc" id="L1311">            }</span>
        });
<span class="fc" id="L1313">    }</span>

    /**
     * Returns a map with the current prefix lookup objects. This map is
     * obtained from the {@code ConfigurationInterpolator} of the configuration
     * under construction.
     *
     * @return the map with current prefix lookups (may be &lt;b&gt;null&lt;/b&gt;)
     */
    private Map&lt;String, ? extends Lookup&gt; fetchPrefixLookups()
    {
<span class="fc" id="L1324">        final CombinedConfiguration cc = getConfigurationUnderConstruction();</span>
<span class="fc bfc" id="L1325" title="All 2 branches covered.">        return (cc != null) ? cc.getInterpolator().getLookups() : null;</span>
    }

    /**
     * Creates {@code ConfigurationDeclaration} objects for the specified
     * configurations.
     *
     * @param configs the list with configurations
     * @return a collection with corresponding declarations
     */
    private Collection&lt;ConfigurationDeclaration&gt; createDeclarations(
            final Collection&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; configs)
    {
<span class="fc" id="L1338">        final Collection&lt;ConfigurationDeclaration&gt; declarations =</span>
<span class="fc" id="L1339">                new ArrayList&lt;&gt;(configs.size());</span>
<span class="fc bfc" id="L1340" title="All 2 branches covered.">        for (final HierarchicalConfiguration&lt;?&gt; c : configs)</span>
        {
<span class="fc" id="L1342">            declarations.add(new ConfigurationDeclaration(this, c));</span>
<span class="fc" id="L1343">        }</span>
<span class="fc" id="L1344">        return declarations;</span>
    }

    /**
     * Initializes the list nodes of the node combiner for the given combined
     * configuration. This information can be set in the header section of the
     * configuration definition file for both the override and the union
     * combiners.
     *
     * @param cc the combined configuration to initialize
     * @param defConfig the definition configuration
     * @param key the key for the list nodes
     */
    private static void initNodeCombinerListNodes(final CombinedConfiguration cc,
            final HierarchicalConfiguration&lt;?&gt; defConfig, final String key)
    {
<span class="fc" id="L1360">        final List&lt;Object&gt; listNodes = defConfig.getList(key);</span>
<span class="fc bfc" id="L1361" title="All 2 branches covered.">        for (final Object listNode : listNodes)</span>
        {
<span class="fc" id="L1363">            cc.getNodeCombiner().addListNode((String) listNode);</span>
<span class="fc" id="L1364">        }</span>
<span class="fc" id="L1365">    }</span>

    /**
     * Creates the map with the default configuration builder providers.
     *
     * @return the map with default providers
     */
    private static Map&lt;String, ConfigurationBuilderProvider&gt; createDefaultProviders()
    {
<span class="fc" id="L1374">        final Map&lt;String, ConfigurationBuilderProvider&gt; providers =</span>
                new HashMap&lt;&gt;();
<span class="fc bfc" id="L1376" title="All 2 branches covered.">        for (int i = 0; i &lt; DEFAULT_TAGS.length; i++)</span>
        {
<span class="fc" id="L1378">            providers.put(DEFAULT_TAGS[i], DEFAULT_PROVIDERS[i]);</span>
        }
<span class="fc" id="L1380">        return providers;</span>
    }

    static
    {
<span class="fc" id="L1385">        DEFAULT_PROVIDERS_MAP = createDefaultProviders();</span>
<span class="fc" id="L1386">    }</span>

    /**
     * A data class for storing information about all configuration sources
     * defined for a combined builder.
     */
    private class ConfigurationSourceData
    {
        /** A list with data for all builders for override configurations. */
        private final List&lt;ConfigurationDeclaration&gt; overrideDeclarations;

        /** A list with data for all builders for union configurations. */
        private final List&lt;ConfigurationDeclaration&gt; unionDeclarations;

        /** A list with the builders for override configurations. */
        private final List&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; overrideBuilders;

        /** A list with the builders for union configurations. */
        private final List&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; unionBuilders;

        /** A map for direct access to a builder by its name. */
        private final Map&lt;String, ConfigurationBuilder&lt;? extends Configuration&gt;&gt; namedBuilders;

        /** A collection with all child builders. */
        private final Collection&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; allBuilders;

        /** A listener for reacting on changes of sub builders. */
        private final EventListener&lt;ConfigurationBuilderEvent&gt; changeListener;

        /**
         * Creates a new instance of {@code ConfigurationSourceData}.
         */
        public ConfigurationSourceData()
<span class="fc" id="L1419">        {</span>
<span class="fc" id="L1420">            overrideDeclarations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1421">            unionDeclarations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1422">            overrideBuilders = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1423">            unionBuilders = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1424">            namedBuilders = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1425">            allBuilders = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L1426">            changeListener = createBuilderChangeListener();</span>
<span class="fc" id="L1427">        }</span>

        /**
         * Initializes this object from the specified definition configuration.
         *
         * @param config the definition configuration
         * @throws ConfigurationException if an error occurs
         */
        public void initFromDefinitionConfiguration(
                final HierarchicalConfiguration&lt;?&gt; config) throws ConfigurationException
        {
<span class="fc" id="L1438">            overrideDeclarations.addAll(createDeclarations(fetchTopLevelOverrideConfigs(config)));</span>
<span class="fc" id="L1439">            overrideDeclarations.addAll(createDeclarations(config.childConfigurationsAt(KEY_OVERRIDE)));</span>
<span class="fc" id="L1440">            unionDeclarations.addAll(createDeclarations(config.childConfigurationsAt(KEY_UNION)));</span>
<span class="fc" id="L1441">        }</span>

        /**
         * Processes the declaration of configuration builder providers, creates
         * the corresponding builder if necessary, obtains configurations, and
         * adds them to the specified result configuration.
         *
         * @param ccResult the result configuration
         * @param srcDecl the collection with the declarations of configuration
         *        sources to process
         * @return a list with configuration builders
         * @throws ConfigurationException if an error occurs
         */
        public List&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; createAndAddConfigurations(
                final CombinedConfiguration ccResult,
                final List&lt;ConfigurationDeclaration&gt; srcDecl,
                final List&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; builders)
                throws ConfigurationException
        {
<span class="fc" id="L1460">            final boolean createBuilders = builders.isEmpty();</span>
            List&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; newBuilders;
<span class="fc bfc" id="L1462" title="All 2 branches covered.">            if (createBuilders)</span>
            {
<span class="fc" id="L1464">                newBuilders = new ArrayList&lt;&gt;(srcDecl.size());</span>
            }
            else
            {
<span class="fc" id="L1468">                newBuilders = builders;</span>
            }

<span class="fc bfc" id="L1471" title="All 2 branches covered.">            for (int i = 0; i &lt; srcDecl.size(); i++)</span>
            {
                ConfigurationBuilder&lt;? extends Configuration&gt; b;
<span class="fc bfc" id="L1474" title="All 2 branches covered.">                if (createBuilders)</span>
                {
<span class="fc" id="L1476">                    b = createConfigurationBuilder(srcDecl.get(i));</span>
<span class="fc" id="L1477">                    newBuilders.add(b);</span>
                }
                else
                {
<span class="fc" id="L1481">                    b = builders.get(i);</span>
                }
<span class="fc" id="L1483">                addChildConfiguration(ccResult, srcDecl.get(i), b);</span>
            }

<span class="fc" id="L1486">            return newBuilders;</span>
        }

        /**
         * Frees resources used by this object and performs clean up. This
         * method is called when the owning builder is reset.
         */
        public void cleanUp()
        {
<span class="fc bfc" id="L1495" title="All 2 branches covered.">            for (final ConfigurationBuilder&lt;?&gt; b : getChildBuilders())</span>
            {
<span class="fc" id="L1497">                b.removeEventListener(ConfigurationBuilderEvent.RESET,</span>
                        changeListener);
<span class="fc" id="L1499">            }</span>
<span class="fc" id="L1500">            namedBuilders.clear();</span>
<span class="fc" id="L1501">        }</span>

        /**
         * Returns a collection containing the builders for all child
         * configuration sources.
         *
         * @return the child configuration builders
         */
        public Collection&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; getChildBuilders()
        {
<span class="fc" id="L1511">            return allBuilders;</span>
        }

        /**
         * Returns a collection with all configuration source declarations
         * defined in the override section.
         *
         * @return the override configuration builders
         */
        public List&lt;ConfigurationDeclaration&gt; getOverrideSources()
        {
<span class="fc" id="L1522">            return overrideDeclarations;</span>
        }

        /**
         * Returns a collection with all configuration source declarations
         * defined in the union section.
         *
         * @return the union configuration builders
         */
        public List&lt;ConfigurationDeclaration&gt; getUnionSources()
        {
<span class="fc" id="L1533">            return unionDeclarations;</span>
        }

        /**
         * Returns the {@code ConfigurationBuilder} with the given name. If no
         * such builder is defined in the definition configuration, result is
         * &lt;b&gt;null&lt;/b&gt;.
         *
         * @param name the name of the builder in question
         * @return the builder with this name or &lt;b&gt;null&lt;/b&gt;
         */
        public ConfigurationBuilder&lt;? extends Configuration&gt; getNamedBuilder(
                final String name)
        {
<span class="fc" id="L1547">            return namedBuilders.get(name);</span>
        }

        /**
         * Returns a set with the names of all known named builders.
         *
         * @return the names of the available sub builders
         */
        public Set&lt;String&gt; builderNames()
        {
<span class="fc" id="L1557">            return namedBuilders.keySet();</span>
        }

        /**
         * Creates a configuration builder based on a source declaration in the
         * definition configuration.
         *
         * @param decl the current {@code ConfigurationDeclaration}
         * @return the newly created builder
         * @throws ConfigurationException if an error occurs
         */
        private ConfigurationBuilder&lt;? extends Configuration&gt; createConfigurationBuilder(
                final ConfigurationDeclaration decl) throws ConfigurationException
        {
<span class="fc" id="L1571">            final ConfigurationBuilderProvider provider =</span>
<span class="fc" id="L1572">                    providerForTag(decl.getConfiguration().getRootElementName());</span>
<span class="pc bpc" id="L1573" title="1 of 2 branches missed.">            if (provider == null)</span>
            {
<span class="nc" id="L1575">                throw new ConfigurationException(</span>
                        &quot;Unsupported configuration source: &quot;
<span class="nc" id="L1577">                                + decl.getConfiguration().getRootElementName());</span>
            }

<span class="fc" id="L1580">            final ConfigurationBuilder&lt;? extends Configuration&gt; builder =</span>
<span class="fc" id="L1581">                    provider.getConfigurationBuilder(decl);</span>
<span class="fc bfc" id="L1582" title="All 2 branches covered.">            if (decl.getName() != null)</span>
            {
<span class="fc" id="L1584">                namedBuilders.put(decl.getName(), builder);</span>
            }
<span class="fc" id="L1586">            allBuilders.add(builder);</span>
<span class="fc" id="L1587">            builder.addEventListener(ConfigurationBuilderEvent.RESET,</span>
                    changeListener);
<span class="fc" id="L1589">            return builder;</span>
        }

        /**
         * Creates a new configuration using the specified builder and adds it
         * to the resulting combined configuration.
         *
         * @param ccResult the resulting combined configuration
         * @param decl the current {@code ConfigurationDeclaration}
         * @param builder the configuration builder
         * @throws ConfigurationException if an error occurs
         */
        private void addChildConfiguration(final CombinedConfiguration ccResult,
                final ConfigurationDeclaration decl,
                final ConfigurationBuilder&lt;? extends Configuration&gt; builder)
                throws ConfigurationException
        {
            try
            {
<span class="fc" id="L1608">                ccResult.addConfiguration(</span>
<span class="fc" id="L1609">                        builder.getConfiguration(),</span>
<span class="fc" id="L1610">                        decl.getName(), decl.getAt());</span>
            }
<span class="fc" id="L1612">            catch (final ConfigurationException cex)</span>
            {
                // ignore exceptions for optional configurations
<span class="fc bfc" id="L1615" title="All 2 branches covered.">                if (!decl.isOptional())</span>
                {
<span class="fc" id="L1617">                    throw cex;</span>
                }
<span class="fc" id="L1619">            }</span>
<span class="fc" id="L1620">        }</span>

        /**
         * Creates a listener for builder change events. This listener is
         * registered at all builders for child configurations.
         */
        private EventListener&lt;ConfigurationBuilderEvent&gt; createBuilderChangeListener()
        {
<span class="fc" id="L1628">            return new EventListener&lt;ConfigurationBuilderEvent&gt;()</span>
<span class="fc" id="L1629">            {</span>
                @Override
                public void onEvent(final ConfigurationBuilderEvent event)
                {
<span class="fc" id="L1633">                    resetResult();</span>
<span class="fc" id="L1634">                }</span>
            };
        }

        /**
         * Finds the override configurations that are defined as top level
         * elements in the configuration definition file. This method fetches
         * the child elements of the root node and removes the nodes that
         * represent other configuration sections. The remaining nodes are
         * treated as definitions for override configurations.
         *
         * @param config the definition configuration
         * @return a list with sub configurations for the top level override
         *         configurations
         */
        private List&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; fetchTopLevelOverrideConfigs(
                final HierarchicalConfiguration&lt;?&gt; config)
        {

<span class="fc" id="L1653">            final List&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; configs =</span>
<span class="fc" id="L1654">                    config.childConfigurationsAt(null);</span>
<span class="fc" id="L1655">            for (final Iterator&lt;? extends HierarchicalConfiguration&lt;?&gt;&gt; it =</span>
<span class="fc bfc" id="L1656" title="All 2 branches covered.">                    configs.iterator(); it.hasNext();)</span>
            {
<span class="fc" id="L1658">                final String nodeName = it.next().getRootElementName();</span>
<span class="fc bfc" id="L1659" title="All 2 branches covered.">                for (final String element : CONFIG_SECTIONS)</span>
                {
<span class="fc bfc" id="L1661" title="All 2 branches covered.">                    if (element.equals(nodeName))</span>
                    {
<span class="fc" id="L1663">                        it.remove();</span>
<span class="fc" id="L1664">                        break;</span>
                    }
                }
<span class="fc" id="L1667">            }</span>
<span class="fc" id="L1668">            return configs;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>