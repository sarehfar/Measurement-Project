<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InMemoryNodeModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Configuration</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2.tree</a> &gt; <span class="el_source">InMemoryNodeModel.java</span></div><h1>InMemoryNodeModel.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.configuration2.tree;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;

import org.apache.commons.configuration2.ex.ConfigurationRuntimeException;
import org.apache.commons.lang3.mutable.Mutable;
import org.apache.commons.lang3.mutable.MutableObject;

/**
 * &lt;p&gt;
 * A specialized node model implementation which operates on
 * {@link ImmutableNode} structures.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This {@code NodeModel} implementation keeps all its data as a tree of
 * {@link ImmutableNode} objects in memory. The managed structure can be
 * manipulated in a thread-safe, non-blocking way. This is achieved by using
 * atomic variables: The root of the tree is stored in an atomic reference
 * variable. Each update operation causes a new structure to be constructed
 * (which reuses as much from the original structure as possible). The old root
 * node is then replaced by the new one using an atomic compare-and-set
 * operation. If this fails, the manipulation has to be done anew on the updated
 * structure.
 * &lt;/p&gt;
 *
 * @version $Id$
 * @since 2.0
 */
public class InMemoryNodeModel implements NodeModel&lt;ImmutableNode&gt;
{
    /**
     * A dummy node handler instance used in operations which require only a
     * limited functionality.
     */
<span class="fc" id="L59">    private static final NodeHandler&lt;ImmutableNode&gt; DUMMY_HANDLER =</span>
            new TreeData(null,
<span class="fc" id="L61">                    Collections.&lt;ImmutableNode, ImmutableNode&gt; emptyMap(),</span>
<span class="fc" id="L62">                    Collections.&lt;ImmutableNode, ImmutableNode&gt; emptyMap(), null, new ReferenceTracker());</span>

    /** Stores information about the current nodes structure. */
    private final AtomicReference&lt;TreeData&gt; structure;

    /**
     * Creates a new instance of {@code InMemoryNodeModel} which is initialized
     * with an empty root node.
     */
    public InMemoryNodeModel()
    {
<span class="fc" id="L73">        this(null);</span>
<span class="fc" id="L74">    }</span>

    /**
     * Creates a new instance of {@code InMemoryNodeModel} and initializes it
     * from the given root node. If the passed in node is &lt;b&gt;null&lt;/b&gt;, a new,
     * empty root node is created.
     *
     * @param root the new root node for this model
     */
    public InMemoryNodeModel(ImmutableNode root)
<span class="fc" id="L84">    {</span>
<span class="fc" id="L85">        structure =</span>
                new AtomicReference&lt;&gt;(
<span class="fc" id="L87">                        createTreeData(initialRootNode(root), null));</span>
<span class="fc" id="L88">    }</span>

    /**
     * Returns the root node of this mode. Note: This method should be used with
     * care. The model may be updated concurrently which causes the root node to
     * be replaced. If the root node is to be processed further (e.g. by
     * executing queries on it), the model should be asked for its
     * {@code NodeHandler}, and the root node should be obtained from there. The
     * connection between a node handler and its root node remain constant
     * because an update of the model causes the whole node handler to be
     * replaced.
     *
     * @return the current root node
     */
    public ImmutableNode getRootNode()
    {
<span class="fc" id="L104">        return getTreeData().getRootNode();</span>
    }

    /**
     * {@inheritDoc} {@code InMemoryNodeModel} implements the
     * {@code NodeHandler} interface itself. So this implementation just returns
     * the &lt;strong&gt;this&lt;/strong&gt; reference.
     */
    @Override
    public NodeHandler&lt;ImmutableNode&gt; getNodeHandler()
    {
<span class="fc" id="L115">        return getReferenceNodeHandler();</span>
    }

    @Override
    public void addProperty(String key, Iterable&lt;?&gt; values,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L122">        addProperty(key, null, values, resolver);</span>
<span class="fc" id="L123">    }</span>

    /**
     * Adds new property values using a tracked node as root node. This method
     * works like the normal {@code addProperty()} method, but the origin of the
     * operation (also for the interpretation of the passed in key) is a tracked
     * node identified by the passed in {@code NodeSelector}. The selector can
     * be &lt;b&gt;null&lt;/b&gt;, then the root node is assumed.
     *
     * @param key the key
     * @param selector the {@code NodeSelector} defining the root node (or
     *        &lt;b&gt;null&lt;/b&gt;)
     * @param values the values to be added
     * @param resolver the {@code NodeKeyResolver}
     * @throws ConfigurationRuntimeException if the selector cannot be resolved
     */
    public void addProperty(final String key, NodeSelector selector,
            final Iterable&lt;?&gt; values,
            final NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (valuesNotEmpty(values))</span>
        {
<span class="fc" id="L145">            updateModel(new TransactionInitializer()</span>
<span class="fc" id="L146">            {</span>
                @Override
                public boolean initTransaction(ModelTransaction tx)
                {
<span class="fc" id="L150">                    initializeAddTransaction(tx, key, values, resolver);</span>
<span class="fc" id="L151">                    return true;</span>
                }
            }, selector, resolver);
        }
<span class="fc" id="L155">    }</span>

    @Override
    public void addNodes(String key, Collection&lt;? extends ImmutableNode&gt; nodes,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L161">        addNodes(key, null, nodes, resolver);</span>
<span class="fc" id="L162">    }</span>

    /**
     * Adds new nodes using a tracked node as root node. This method works like
     * the normal {@code addNodes()} method, but the origin of the operation
     * (also for the interpretation of the passed in key) is a tracked node
     * identified by the passed in {@code NodeSelector}. The selector can be
     * &lt;b&gt;null&lt;/b&gt;, then the root node is assumed.
     *
     * @param key the key
     * @param selector the {@code NodeSelector} defining the root node (or
     *        &lt;b&gt;null&lt;/b&gt;)
     * @param nodes the collection of new nodes to be added
     * @param resolver the {@code NodeKeyResolver}
     * @throws ConfigurationRuntimeException if the selector cannot be resolved
     */
    public void addNodes(final String key, NodeSelector selector,
            final Collection&lt;? extends ImmutableNode&gt; nodes,
            final NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc bfc" id="L182" title="All 4 branches covered.">        if (nodes != null &amp;&amp; !nodes.isEmpty())</span>
        {
<span class="fc" id="L184">            updateModel(new TransactionInitializer()</span>
<span class="fc" id="L185">            {</span>
                @Override
                public boolean initTransaction(ModelTransaction tx)
                {
<span class="fc" id="L189">                    List&lt;QueryResult&lt;ImmutableNode&gt;&gt; results =</span>
<span class="fc" id="L190">                            resolver.resolveKey(tx.getQueryRoot(), key,</span>
<span class="fc" id="L191">                                    tx.getCurrentData());</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">                    if (results.size() == 1)</span>
                    {
<span class="fc bfc" id="L194" title="All 2 branches covered.">                        if (results.get(0).isAttributeResult())</span>
                        {
<span class="fc" id="L196">                            throw attributeKeyException(key);</span>
                        }
<span class="fc" id="L198">                        tx.addAddNodesOperation(results.get(0).getNode(), nodes);</span>
                    }
                    else
                    {
<span class="fc" id="L202">                        NodeAddData&lt;ImmutableNode&gt; addData =</span>
<span class="fc" id="L203">                                resolver.resolveAddKey(tx.getQueryRoot(), key,</span>
<span class="fc" id="L204">                                        tx.getCurrentData());</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">                        if (addData.isAttribute())</span>
                        {
<span class="fc" id="L207">                            throw attributeKeyException(key);</span>
                        }
<span class="fc" id="L209">                        ImmutableNode newNode =</span>
<span class="fc" id="L210">                                new ImmutableNode.Builder(nodes.size())</span>
<span class="fc" id="L211">                                        .name(addData.getNewNodeName())</span>
<span class="fc" id="L212">                                        .addChildren(nodes).create();</span>
<span class="fc" id="L213">                        addNodesByAddData(tx, addData,</span>
<span class="fc" id="L214">                                Collections.singleton(newNode));</span>
                    }
<span class="fc" id="L216">                    return true;</span>
                }
            }, selector, resolver);
        }
<span class="fc" id="L220">    }</span>

    @Override
    public void setProperty(String key, Object value,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L226">        setProperty(key, null, value, resolver);</span>
<span class="fc" id="L227">    }</span>

    /**
     * Sets the value of a property using a tracked node as root node. This
     * method works like the normal {@code setProperty()} method, but the origin
     * of the operation (also for the interpretation of the passed in key) is a
     * tracked node identified by the passed in {@code NodeSelector}. The
     * selector can be &lt;b&gt;null&lt;/b&gt;, then the root node is assumed.
     *
     * @param key the key
     * @param selector the {@code NodeSelector} defining the root node (or
     *        &lt;b&gt;null&lt;/b&gt;)
     * @param value the new value for this property
     * @param resolver the {@code NodeKeyResolver}
     * @throws ConfigurationRuntimeException if the selector cannot be resolved
     */
    public void setProperty(final String key, NodeSelector selector,
            final Object value, final NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L246">        updateModel(new TransactionInitializer()</span>
<span class="fc" id="L247">        {</span>
            @Override
            public boolean initTransaction(ModelTransaction tx)
            {
<span class="fc" id="L251">                boolean added = false;</span>
<span class="fc" id="L252">                NodeUpdateData&lt;ImmutableNode&gt; updateData =</span>
<span class="fc" id="L253">                        resolver.resolveUpdateKey(tx.getQueryRoot(), key,</span>
<span class="fc" id="L254">                                value, tx.getCurrentData());</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">                if (!updateData.getNewValues().isEmpty())</span>
                {
<span class="fc" id="L257">                    initializeAddTransaction(tx, key,</span>
<span class="fc" id="L258">                            updateData.getNewValues(), resolver);</span>
<span class="fc" id="L259">                    added = true;</span>
                }
<span class="fc" id="L261">                boolean cleared =</span>
<span class="fc" id="L262">                        initializeClearTransaction(tx,</span>
<span class="fc" id="L263">                                updateData.getRemovedNodes());</span>
<span class="fc" id="L264">                boolean updated =</span>
<span class="fc" id="L265">                        initializeUpdateTransaction(tx,</span>
<span class="fc" id="L266">                                updateData.getChangedValues());</span>
<span class="fc bfc" id="L267" title="All 6 branches covered.">                return added || cleared || updated;</span>
            }
        }, selector, resolver);
<span class="fc" id="L270">    }</span>

    /**
     * {@inheritDoc} This implementation checks whether nodes become undefined
     * after subtrees have been removed. If this is the case, such nodes are
     * removed, too. Return value is a collection with {@code QueryResult}
     * objects for the elements to be removed from the model.
     */
    @Override
    public List&lt;QueryResult&lt;ImmutableNode&gt;&gt; clearTree(String key,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L282">        return clearTree(key, null, resolver);</span>
    }

    /**
     * Clears a whole sub tree using a tracked node as root node. This method
     * works like the normal {@code clearTree()} method, but the origin of the
     * operation (also for the interpretation of the passed in key) is a tracked
     * node identified by the passed in {@code NodeSelector}. The selector can
     * be &lt;b&gt;null&lt;/b&gt;, then the root node is assumed.
     *
     * @param key the key
     * @param selector the {@code NodeSelector} defining the root node (or
     *        &lt;b&gt;null&lt;/b&gt;)
     * @param resolver the {@code NodeKeyResolver}
     * @return a list with the results to be removed
     * @throws ConfigurationRuntimeException if the selector cannot be resolved
     */
    public List&lt;QueryResult&lt;ImmutableNode&gt;&gt; clearTree(final String key,
            NodeSelector selector, final NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L302">        final List&lt;QueryResult&lt;ImmutableNode&gt;&gt; removedElements =</span>
                new LinkedList&lt;&gt;();
<span class="fc" id="L304">        updateModel(new TransactionInitializer()</span>
<span class="fc" id="L305">        {</span>
            @Override
            public boolean initTransaction(ModelTransaction tx)
            {
<span class="fc" id="L309">                boolean changes = false;</span>
<span class="fc" id="L310">                TreeData currentStructure = tx.getCurrentData();</span>
<span class="fc" id="L311">                List&lt;QueryResult&lt;ImmutableNode&gt;&gt; results = resolver.resolveKey(</span>
<span class="fc" id="L312">                        tx.getQueryRoot(), key, currentStructure);</span>
<span class="fc" id="L313">                removedElements.clear();</span>
<span class="fc" id="L314">                removedElements.addAll(results);</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">                for (QueryResult&lt;ImmutableNode&gt; result : results)</span>
                {
<span class="fc bfc" id="L317" title="All 2 branches covered.">                    if (result.isAttributeResult())</span>
                    {
<span class="fc" id="L319">                        tx.addRemoveAttributeOperation(result.getNode(),</span>
<span class="fc" id="L320">                                result.getAttributeName());</span>
                    }
                    else
                    {
<span class="fc bfc" id="L324" title="All 2 branches covered.">                        if (result.getNode() == currentStructure.getRootNode())</span>
                        {
                            // the whole model is to be cleared
<span class="fc" id="L327">                            clear(resolver);</span>
<span class="fc" id="L328">                            return false;</span>
                        }
<span class="fc" id="L330">                        tx.addRemoveNodeOperation(</span>
<span class="fc" id="L331">                                currentStructure.getParent(result.getNode()),</span>
<span class="fc" id="L332">                                result.getNode());</span>
                    }
<span class="fc" id="L334">                    changes = true;</span>
<span class="fc" id="L335">                }</span>
<span class="fc" id="L336">                return changes;</span>
            }
        }, selector, resolver);

<span class="fc" id="L340">        return removedElements;</span>
    }

    /**
     * {@inheritDoc} If this operation leaves an affected node in an undefined
     * state, it is removed from the model.
     */
    @Override
    public void clearProperty(String key,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L351">        clearProperty(key, null, resolver);</span>
<span class="fc" id="L352">    }</span>

    /**
     * Clears a property using a tracked node as root node. This method works
     * like the normal {@code clearProperty()} method, but the origin of the
     * operation (also for the interpretation of the passed in key) is a tracked
     * node identified by the passed in {@code NodeSelector}. The selector can
     * be &lt;b&gt;null&lt;/b&gt;, then the root node is assumed.
     *
     * @param key the key
     * @param selector the {@code NodeSelector} defining the root node (or
     *        &lt;b&gt;null&lt;/b&gt;)
     * @param resolver the {@code NodeKeyResolver}
     * @throws ConfigurationRuntimeException if the selector cannot be resolved
     */
    public void clearProperty(final String key, NodeSelector selector,
            final NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L370">        updateModel(new TransactionInitializer()</span>
<span class="fc" id="L371">        {</span>
            @Override
            public boolean initTransaction(ModelTransaction tx)
            {
<span class="fc" id="L375">                List&lt;QueryResult&lt;ImmutableNode&gt;&gt; results =</span>
<span class="fc" id="L376">                        resolver.resolveKey(tx.getQueryRoot(), key,</span>
<span class="fc" id="L377">                                tx.getCurrentData());</span>
<span class="fc" id="L378">                return initializeClearTransaction(tx, results);</span>
            }
        }, selector, resolver);
<span class="fc" id="L381">    }</span>

    /**
     * {@inheritDoc} A new empty root node is created with the same name as the
     * current root node. Implementation note: Because this is a hard reset the
     * usual dance for dealing with concurrent updates is not required here.
     *
     * @param resolver the {@code NodeKeyResolver}
     */
    @Override
    public void clear(NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L393">        ImmutableNode newRoot =</span>
<span class="fc" id="L394">                new ImmutableNode.Builder().name(getRootNode().getNodeName())</span>
<span class="fc" id="L395">                        .create();</span>
<span class="fc" id="L396">        setRootNode(newRoot);</span>
<span class="fc" id="L397">    }</span>

    /**
     * {@inheritDoc} This implementation simply returns the current root node of this
     * model.
     */
    @Override
    public ImmutableNode getInMemoryRepresentation()
    {
<span class="fc" id="L406">        return getTreeData().getRootNode();</span>
    }

    /**
     * {@inheritDoc} All tracked nodes and reference objects managed by this
     * model are cleared.Care has to be taken when this method is used and the
     * model is accessed by multiple threads. It is not deterministic which
     * concurrent operations see the old root and which see the new root node.
     *
     * @param newRoot the new root node to be set (can be &lt;b&gt;null&lt;/b&gt;, then an
     *        empty root node is set)
     */
    @Override
    public void setRootNode(ImmutableNode newRoot)
    {
<span class="fc" id="L421">        structure.set(createTreeData(initialRootNode(newRoot), structure.get()));</span>
<span class="fc" id="L422">    }</span>

    /**
     * Replaces the root node of this model. This method is similar to
     * {@link #setRootNode(ImmutableNode)}; however, tracked nodes will not get
     * lost. The model applies the selectors of all tracked nodes on the new
     * nodes hierarchy, so that corresponding nodes are selected (this may cause
     * nodes to become detached if a select operation fails). This operation is
     * useful if the new nodes hierarchy to be set is known to be similar to the
     * old one. Note that reference objects are lost; there is no way to
     * automatically match nodes between the old and the new nodes hierarchy.
     *
     * @param newRoot the new root node to be set (must not be &lt;b&gt;null&lt;/b&gt;)
     * @param resolver the {@code NodeKeyResolver}
     * @throws IllegalArgumentException if the new root node is &lt;b&gt;null&lt;/b&gt;
     */
    public void replaceRoot(ImmutableNode newRoot,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (newRoot == null)</span>
        {
<span class="fc" id="L443">            throw new IllegalArgumentException(</span>
                    &quot;Replaced root node must not be null!&quot;);
        }

<span class="fc" id="L447">        TreeData current = structure.get();</span>
        // this step is needed to get a valid NodeHandler
<span class="fc" id="L449">        TreeData temp =</span>
<span class="fc" id="L450">                createTreeDataForRootAndTracker(newRoot,</span>
<span class="fc" id="L451">                        current.getNodeTracker());</span>
<span class="fc" id="L452">        structure.set(temp.updateNodeTracker(temp.getNodeTracker().update(</span>
                newRoot, null, resolver, temp)));
<span class="fc" id="L454">    }</span>

    /**
     * Merges the root node of this model with the specified node. This method
     * is typically caused by configuration implementations when a configuration
     * source is loaded, and its data has to be added to the model. It is
     * possible to define the new name of the root node and to pass in a map
     * with reference objects.
     *
     * @param node the node to be merged with the root node
     * @param rootName the new name of the root node; can be &lt;b&gt;null&lt;/b&gt;, then
     *        the name of the root node is not changed unless it is &lt;b&gt;null&lt;/b&gt;
     * @param references an optional map with reference objects
     * @param rootRef an optional reference object for the new root node
     * @param resolver the {@code NodeKeyResolver}
     */
    public void mergeRoot(final ImmutableNode node, final String rootName,
            final Map&lt;ImmutableNode, ?&gt; references, final Object rootRef,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L474">        updateModel(new TransactionInitializer()</span>
<span class="fc" id="L475">        {</span>
            @Override
            public boolean initTransaction(ModelTransaction tx)
            {
<span class="fc" id="L479">                TreeData current = tx.getCurrentData();</span>
<span class="fc" id="L480">                String newRootName =</span>
<span class="fc" id="L481">                        determineRootName(current.getRootNode(), node, rootName);</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">                if (newRootName != null)</span>
                {
<span class="fc" id="L484">                    tx.addChangeNodeNameOperation(current.getRootNode(),</span>
                            newRootName);
                }
<span class="fc" id="L487">                tx.addAddNodesOperation(current.getRootNode(),</span>
<span class="fc" id="L488">                        node.getChildren());</span>
<span class="fc" id="L489">                tx.addAttributesOperation(current.getRootNode(),</span>
<span class="fc" id="L490">                        node.getAttributes());</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">                if (node.getValue() != null)</span>
                {
<span class="fc" id="L493">                    tx.addChangeNodeValueOperation(current.getRootNode(),</span>
<span class="fc" id="L494">                            node.getValue());</span>
                }
<span class="fc bfc" id="L496" title="All 2 branches covered.">                if (references != null)</span>
                {
<span class="fc" id="L498">                    tx.addNewReferences(references);</span>
                }
<span class="fc bfc" id="L500" title="All 2 branches covered.">                if (rootRef != null)</span>
                {
<span class="fc" id="L502">                    tx.addNewReference(current.getRootNode(), rootRef);</span>
                }
<span class="fc" id="L504">                return true;</span>
            }
        }, null, resolver);
<span class="fc" id="L507">    }</span>

    /**
     * Adds a node to be tracked. After this method has been called with a
     * specific {@code NodeSelector}, the node associated with this key can be
     * always obtained using {@link #getTrackedNode(NodeSelector)} with the same
     * selector. This is useful because during updates of a model parts of the
     * structure are replaced. Therefore, it is not a good idea to simply hold a
     * reference to a node; this might become outdated soon. Rather, the node
     * should be tracked. This mechanism ensures that always the correct node
     * reference can be obtained.
     *
     * @param selector the {@code NodeSelector} defining the desired node
     * @param resolver the {@code NodeKeyResolver}
     * @throws ConfigurationRuntimeException if the selector does not select a
     *         single node
     */
    public void trackNode(NodeSelector selector,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
        boolean done;
        do
        {
<span class="fc" id="L530">            TreeData current = structure.get();</span>
<span class="fc" id="L531">            NodeTracker newTracker =</span>
<span class="fc" id="L532">                    current.getNodeTracker().trackNode(current.getRootNode(),</span>
                            selector, resolver, current);
<span class="fc" id="L534">            done =</span>
<span class="fc" id="L535">                    structure.compareAndSet(current,</span>
<span class="fc" id="L536">                            current.updateNodeTracker(newTracker));</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">        } while (!done);</span>
<span class="fc" id="L538">    }</span>

    /**
     * Allows tracking all nodes selected by a key. This method evaluates the
     * specified key on the current nodes structure. For all selected nodes
     * corresponding {@code NodeSelector} objects are created, and they are
     * tracked. The returned collection of {@code NodeSelector} objects can be
     * used for interacting with the selected nodes.
     *
     * @param key the key for selecting the nodes to track
     * @param resolver the {@code NodeKeyResolver}
     * @return a collection with the {@code NodeSelector} objects for the new
     *         tracked nodes
     */
    public Collection&lt;NodeSelector&gt; selectAndTrackNodes(String key,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L555">        Mutable&lt;Collection&lt;NodeSelector&gt;&gt; refSelectors =</span>
                new MutableObject&lt;&gt;();
        boolean done;
        do
        {
<span class="fc" id="L560">            TreeData current = structure.get();</span>
<span class="fc" id="L561">            List&lt;ImmutableNode&gt; nodes =</span>
<span class="fc" id="L562">                    resolver.resolveNodeKey(current.getRootNode(), key, current);</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">            if (nodes.isEmpty())</span>
            {
<span class="fc" id="L565">                return Collections.emptyList();</span>
            }
<span class="fc" id="L567">            done =</span>
<span class="fc" id="L568">                    structure.compareAndSet(</span>
                            current,
<span class="fc" id="L570">                            createSelectorsForTrackedNodes(refSelectors, nodes,</span>
                                    current, resolver));
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">        } while (!done);</span>
<span class="fc" id="L573">        return refSelectors.getValue();</span>
    }

    /**
     * Tracks all nodes which are children of the node selected by the passed in
     * key. If the key selects exactly one node, for all children of this node
     * {@code NodeSelector} objects are created, and they become tracked nodes.
     * The returned collection of {@code NodeSelector} objects can be used for
     * interacting with the selected nodes.
     *
     * @param key the key for selecting the parent node whose children are to be
     *        tracked
     * @param resolver the {@code NodeKeyResolver}
     * @return a collection with the {@code NodeSelector} objects for the new
     *         tracked nodes
     */
    public Collection&lt;NodeSelector&gt; trackChildNodes(String key,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L592">        Mutable&lt;Collection&lt;NodeSelector&gt;&gt; refSelectors =</span>
                new MutableObject&lt;&gt;();
        boolean done;
        do
        {
<span class="fc" id="L597">            refSelectors.setValue(Collections.&lt;NodeSelector&gt; emptyList());</span>
<span class="fc" id="L598">            TreeData current = structure.get();</span>
<span class="fc" id="L599">            List&lt;ImmutableNode&gt; nodes =</span>
<span class="fc" id="L600">                    resolver.resolveNodeKey(current.getRootNode(), key, current);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">            if (nodes.size() == 1)</span>
            {
<span class="fc" id="L603">                ImmutableNode node = nodes.get(0);</span>
<span class="fc" id="L604">                done =</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">                        node.getChildren().isEmpty()</span>
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">                                || structure.compareAndSet(</span>
                                        current,
<span class="fc" id="L608">                                        createSelectorsForTrackedNodes(</span>
                                                refSelectors,
<span class="fc" id="L610">                                                node.getChildren(), current,</span>
                                                resolver));
<span class="fc" id="L612">            }</span>
            else
            {
<span class="fc" id="L615">                done = true;</span>
            }
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">        } while (!done);</span>
<span class="fc" id="L618">        return refSelectors.getValue();</span>
    }

    /**
     * Tracks a node which is a child of another node selected by the passed in
     * key. If the selected node has a child node with this name, it is tracked
     * and its selector is returned. Otherwise, a new child node with this name
     * is created first.
     *
     * @param key the key for selecting the parent node
     * @param childName the name of the child node
     * @param resolver the {@code NodeKeyResolver}
     * @return the {@code NodeSelector} for the tracked child node
     * @throws ConfigurationRuntimeException if the passed in key does not
     *         select a single node
     */
    public NodeSelector trackChildNodeWithCreation(String key,
            String childName, NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L637">        MutableObject&lt;NodeSelector&gt; refSelector =</span>
                new MutableObject&lt;&gt;();
        boolean done;

        do
        {
<span class="fc" id="L643">            TreeData current = structure.get();</span>
<span class="fc" id="L644">            List&lt;ImmutableNode&gt; nodes =</span>
<span class="fc" id="L645">                    resolver.resolveNodeKey(current.getRootNode(), key, current);</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">            if (nodes.size() != 1)</span>
            {
<span class="fc" id="L648">                throw new ConfigurationRuntimeException(</span>
                        &quot;Key does not select a single node: &quot; + key);
            }

<span class="fc" id="L652">            ImmutableNode parent = nodes.get(0);</span>
<span class="fc" id="L653">            TreeData newData =</span>
<span class="fc" id="L654">                    createDataWithTrackedChildNode(current, parent, childName,</span>
                            resolver, refSelector);

<span class="fc" id="L657">            done = structure.compareAndSet(current, newData);</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">        } while (!done);</span>

<span class="fc" id="L660">        return refSelector.getValue();</span>
    }

    /**
     * Returns the current {@code ImmutableNode} instance associated with the
     * given {@code NodeSelector}. The node must be a tracked node, i.e.
     * {@link #trackNode(NodeSelector, NodeKeyResolver)} must have been called
     * before with the given selector.
     *
     * @param selector the {@code NodeSelector} defining the desired node
     * @return the current {@code ImmutableNode} associated with this selector
     * @throws ConfigurationRuntimeException if the selector is unknown
     */
    public ImmutableNode getTrackedNode(NodeSelector selector)
    {
<span class="fc" id="L675">        return structure.get().getNodeTracker().getTrackedNode(selector);</span>
    }

    /**
     * Replaces a tracked node by another node. If the tracked node is not yet
     * detached, it becomes now detached. The passed in node (which must not be
     * &lt;b&gt;null&lt;/b&gt;) becomes the new root node of an independent model for this
     * tracked node. Further updates of this model do not affect the tracked
     * node's model and vice versa.
     *
     * @param selector the {@code NodeSelector} defining the tracked node
     * @param newNode the node replacing the tracked node (must not be
     *        &lt;b&gt;null&lt;/b&gt;)
     * @throws ConfigurationRuntimeException if the selector cannot be resolved
     * @throws IllegalArgumentException if the replacement node is &lt;b&gt;null&lt;/b&gt;
     */
    public void replaceTrackedNode(NodeSelector selector, ImmutableNode newNode)
    {
<span class="fc bfc" id="L693" title="All 2 branches covered.">        if (newNode == null)</span>
        {
<span class="fc" id="L695">            throw new IllegalArgumentException(</span>
                    &quot;Replacement node must not be null!&quot;);
        }

        boolean done;
        do
        {
<span class="fc" id="L702">            TreeData currentData = structure.get();</span>
<span class="fc" id="L703">            done =</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">                    replaceDetachedTrackedNode(currentData, selector, newNode)</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">                            || replaceActiveTrackedNode(currentData, selector,</span>
                                    newNode);
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        } while (!done);</span>
<span class="fc" id="L708">    }</span>

    /**
     * Returns a {@code NodeHandler} for a tracked node. Such a handler may be
     * required for operations on a sub tree of the model. The handler to be
     * returned depends on the current state of the tracked node. If it is still
     * active, a handler is used which shares some data (especially the parent
     * mapping) with this model. Detached track nodes in contrast have their own
     * separate model; in this case a handler associated with this model is
     * returned.
     *
     * @param selector the {@code NodeSelector} defining the tracked node
     * @return a {@code NodeHandler} for this tracked node
     * @throws ConfigurationRuntimeException if the selector is unknown
     */
    public NodeHandler&lt;ImmutableNode&gt; getTrackedNodeHandler(
            NodeSelector selector)
    {
<span class="fc" id="L726">        TreeData currentData = structure.get();</span>
<span class="fc" id="L727">        InMemoryNodeModel detachedNodeModel =</span>
<span class="fc" id="L728">                currentData.getNodeTracker().getDetachedNodeModel(selector);</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        return (detachedNodeModel != null) ? detachedNodeModel.getNodeHandler()</span>
<span class="fc" id="L730">                : new TrackedNodeHandler(currentData.getNodeTracker()</span>
<span class="fc" id="L731">                        .getTrackedNode(selector), currentData);</span>
    }

    /**
     * Returns a flag whether the specified tracked node is detached. As long as
     * the {@code NodeSelector} associated with that node returns a single
     * instance, the tracked node is said to be &lt;em&gt;life&lt;/em&gt;. If now an update
     * of the model happens which invalidates the selector (maybe the target
     * node was removed), the tracked node becomes detached. It is still
     * possible to query the node; here the latest valid instance is returned.
     * But further changes on the node model are no longer tracked for this
     * node. So even if there are further changes which would make the
     * {@code NodeSelector} valid again, the tracked node stays in detached
     * state.
     *
     * @param selector the {@code NodeSelector} defining the desired node
     * @return a flag whether this tracked node is in detached state
     * @throws ConfigurationRuntimeException if the selector is unknown
     */
    public boolean isTrackedNodeDetached(NodeSelector selector)
    {
<span class="fc" id="L752">        return structure.get().getNodeTracker().isTrackedNodeDetached(selector);</span>
    }

    /**
     * Removes a tracked node. This method is the opposite of
     * {@code trackNode()}. It has to be called if there is no longer the need
     * to track a specific node. Note that for each call of {@code trackNode()}
     * there has to be a corresponding {@code untrackNode()} call. This ensures
     * that multiple observers can track the same node.
     *
     * @param selector the {@code NodeSelector} defining the desired node
     * @throws ConfigurationRuntimeException if the specified node is not
     *         tracked
     */
    public void untrackNode(NodeSelector selector)
    {
        boolean done;
        do
        {
<span class="fc" id="L771">            TreeData current = structure.get();</span>
<span class="fc" id="L772">            NodeTracker newTracker =</span>
<span class="fc" id="L773">                    current.getNodeTracker().untrackNode(selector);</span>
<span class="fc" id="L774">            done =</span>
<span class="fc" id="L775">                    structure.compareAndSet(current,</span>
<span class="fc" id="L776">                            current.updateNodeTracker(newTracker));</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">        } while (!done);</span>
<span class="fc" id="L778">    }</span>

    /**
     * Returns a {@code ReferenceNodeHandler} object for this model. This
     * extended node handler can be used to query references objects stored for
     * this model.
     *
     * @return the {@code ReferenceNodeHandler}
     */
    public ReferenceNodeHandler getReferenceNodeHandler()
    {
<span class="fc" id="L789">        return getTreeData();</span>
    }

    /**
     * Returns the current {@code TreeData} object. This object contains all
     * information about the current node structure.
     *
     * @return the current {@code TreeData} object
     */
    TreeData getTreeData()
    {
<span class="fc" id="L800">        return structure.get();</span>
    }

    /**
     * Updates the mapping from nodes to their parents for the passed in
     * hierarchy of nodes. This method traverses all children and grand-children
     * of the passed in root node. For each node in the subtree the parent
     * relation is added to the map.
     *
     * @param parents the map with parent nodes
     * @param root the root node of the current tree
     */
    static void updateParentMapping(final Map&lt;ImmutableNode, ImmutableNode&gt; parents,
            ImmutableNode root)
    {
<span class="fc" id="L815">        NodeTreeWalker.INSTANCE.walkBFS(root,</span>
                new ConfigurationNodeVisitorAdapter&lt;ImmutableNode&gt;()
<span class="fc" id="L817">                {</span>
                    @Override
                    public void visitBeforeChildren(ImmutableNode node,
                            NodeHandler&lt;ImmutableNode&gt; handler)
                    {
<span class="fc bfc" id="L822" title="All 2 branches covered.">                        for (ImmutableNode c : node.getChildren())</span>
                        {
<span class="fc" id="L824">                            parents.put(c, node);</span>
<span class="fc" id="L825">                        }</span>
<span class="fc" id="L826">                    }</span>
                }, DUMMY_HANDLER);
<span class="fc" id="L828">    }</span>

    /**
     * Checks if the passed in node is defined. Result is &lt;b&gt;true&lt;/b&gt; if the
     * node contains any data.
     *
     * @param node the node in question
     * @return &lt;b&gt;true&lt;/b&gt; if the node is defined, &lt;b&gt;false&lt;/b&gt; otherwise
     */
    static boolean checkIfNodeDefined(ImmutableNode node)
    {
<span class="fc bfc" id="L839" title="All 4 branches covered.">        return node.getValue() != null || !node.getChildren().isEmpty()</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">                || !node.getAttributes().isEmpty();</span>
    }

    /**
     * Initializes a transaction for an add operation.
     *
     * @param tx the transaction to be initialized
     * @param key the key
     * @param values the collection with node values
     * @param resolver the {@code NodeKeyResolver}
     */
    private void initializeAddTransaction(ModelTransaction tx, String key,
            Iterable&lt;?&gt; values, NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L854">        NodeAddData&lt;ImmutableNode&gt; addData =</span>
<span class="fc" id="L855">                resolver.resolveAddKey(tx.getQueryRoot(), key,</span>
<span class="fc" id="L856">                        tx.getCurrentData());</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">        if (addData.isAttribute())</span>
        {
<span class="fc" id="L859">            addAttributeProperty(tx, addData, values);</span>
        }
        else
        {
<span class="fc" id="L863">            addNodeProperty(tx, addData, values);</span>
        }
<span class="fc" id="L865">    }</span>

    /**
     * Creates a {@code TreeData} object for the specified root node.
     *
     * @param root the root node of the current tree
     * @param current the current {@code TreeData} object (may be &lt;b&gt;null&lt;/b&gt;)
     * @return the {@code TreeData} describing the current tree
     */
    private TreeData createTreeData(ImmutableNode root, TreeData current)
    {
        NodeTracker newTracker =
<span class="fc bfc" id="L877" title="All 2 branches covered.">                (current != null) ? current.getNodeTracker()</span>
<span class="fc" id="L878">                        .detachAllTrackedNodes() : new NodeTracker();</span>
<span class="fc" id="L879">        return createTreeDataForRootAndTracker(root, newTracker);</span>
    }

    /**
     * Creates a {@code TreeData} object for the specified root node and
     * {@code NodeTracker}. Other parameters are set to default values.
     *
     * @param root the new root node for this model
     * @param newTracker the new {@code NodeTracker}
     * @return the new {@code TreeData} object
     */
    private TreeData createTreeDataForRootAndTracker(ImmutableNode root,
            NodeTracker newTracker)
    {
<span class="fc" id="L893">        return new TreeData(root, createParentMapping(root),</span>
<span class="fc" id="L894">                Collections.&lt;ImmutableNode, ImmutableNode&gt; emptyMap(),</span>
                newTracker, new ReferenceTracker());
    }

    /**
     * Handles an add property operation if the property to be added is a node.
     *
     * @param tx the transaction
     * @param addData the {@code NodeAddData}
     * @param values the collection with node values
     */
    private static void addNodeProperty(ModelTransaction tx,
            NodeAddData&lt;ImmutableNode&gt; addData, Iterable&lt;?&gt; values)
    {
<span class="fc" id="L908">        Collection&lt;ImmutableNode&gt; newNodes =</span>
<span class="fc" id="L909">                createNodesToAdd(addData.getNewNodeName(), values);</span>
<span class="fc" id="L910">        addNodesByAddData(tx, addData, newNodes);</span>
<span class="fc" id="L911">    }</span>

    /**
     * Initializes a transaction to add a collection of nodes as described by a
     * {@code NodeAddData} object. If necessary, new path nodes are created.
     * Eventually, the new nodes are added as children to the specified target
     * node.
     *
     * @param tx the transaction
     * @param addData the {@code NodeAddData}
     * @param newNodes the collection of new child nodes
     */
    private static void addNodesByAddData(ModelTransaction tx,
            NodeAddData&lt;ImmutableNode&gt; addData,
            Collection&lt;ImmutableNode&gt; newNodes)
    {
<span class="fc bfc" id="L927" title="All 2 branches covered.">        if (addData.getPathNodes().isEmpty())</span>
        {
<span class="fc" id="L929">            tx.addAddNodesOperation(addData.getParent(), newNodes);</span>
        }
        else
        {
<span class="fc" id="L933">            ImmutableNode newChild = createNodeToAddWithPath(addData, newNodes);</span>
<span class="fc" id="L934">            tx.addAddNodeOperation(addData.getParent(), newChild);</span>
        }
<span class="fc" id="L936">    }</span>

    /**
     * Handles an add property operation if the property to be added is an
     * attribute.
     *
     * @param tx the transaction
     * @param addData the {@code NodeAddData}
     * @param values the collection with node values
     */
    private static void addAttributeProperty(ModelTransaction tx,
            NodeAddData&lt;ImmutableNode&gt; addData, Iterable&lt;?&gt; values)
    {
<span class="fc bfc" id="L949" title="All 2 branches covered.">        if (addData.getPathNodes().isEmpty())</span>
        {
<span class="fc" id="L951">            tx.addAttributeOperation(addData.getParent(),</span>
<span class="fc" id="L952">                    addData.getNewNodeName(), values.iterator().next());</span>
        }
        else
        {
<span class="fc" id="L956">            int pathNodeCount = addData.getPathNodes().size();</span>
<span class="fc" id="L957">            ImmutableNode childWithAttribute =</span>
                    new ImmutableNode.Builder()
<span class="fc" id="L959">                            .name(addData.getPathNodes().get(pathNodeCount - 1))</span>
<span class="fc" id="L960">                            .addAttribute(addData.getNewNodeName(),</span>
<span class="fc" id="L961">                                    values.iterator().next()).create();</span>
            ImmutableNode newChild =
<span class="fc bfc" id="L963" title="All 2 branches covered.">                    (pathNodeCount &gt; 1) ? createNodeOnPath(addData</span>
<span class="fc" id="L964">                            .getPathNodes().subList(0, pathNodeCount - 1)</span>
<span class="fc" id="L965">                            .iterator(),</span>
<span class="fc" id="L966">                            Collections.singleton(childWithAttribute))</span>
<span class="fc" id="L967">                            : childWithAttribute;</span>
<span class="fc" id="L968">            tx.addAddNodeOperation(addData.getParent(), newChild);</span>
        }
<span class="fc" id="L970">    }</span>

    /**
     * Creates a collection with new nodes with a given name and a value from a
     * given collection.
     *
     * @param newNodeName the name of the new nodes
     * @param values the collection with node values
     * @return the newly created collection
     */
    private static Collection&lt;ImmutableNode&gt; createNodesToAdd(
            String newNodeName, Iterable&lt;?&gt; values)
    {
<span class="fc" id="L983">        Collection&lt;ImmutableNode&gt; nodes = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">        for (Object value : values)</span>
        {
<span class="fc" id="L986">            nodes.add(new ImmutableNode.Builder().name(newNodeName)</span>
<span class="fc" id="L987">                    .value(value).create());</span>
<span class="fc" id="L988">        }</span>
<span class="fc" id="L989">        return nodes;</span>
    }

    /**
     * Creates a node structure consisting of the path nodes defined by the
     * passed in {@code NodeAddData} instance and all new child nodes.
     *
     * @param addData the {@code NodeAddData}
     * @param newNodes the collection of new child nodes
     * @return the parent node of the newly created hierarchy
     */
    private static ImmutableNode createNodeToAddWithPath(
            NodeAddData&lt;ImmutableNode&gt; addData,
            Collection&lt;ImmutableNode&gt; newNodes)
    {
<span class="fc" id="L1004">        return createNodeOnPath(addData.getPathNodes().iterator(), newNodes);</span>
    }

    /**
     * Recursive helper method for creating a path node for an add operation.
     * All path nodes except for the last have a single child. The last path
     * node has the new nodes as children.
     *
     * @param it the iterator over the names of the path nodes
     * @param newNodes the collection of new child nodes
     * @return the newly created path node
     */
    private static ImmutableNode createNodeOnPath(Iterator&lt;String&gt; it,
            Collection&lt;ImmutableNode&gt; newNodes)
    {
<span class="fc" id="L1019">        String nodeName = it.next();</span>
        ImmutableNode.Builder builder;
<span class="fc bfc" id="L1021" title="All 2 branches covered.">        if (it.hasNext())</span>
        {
<span class="fc" id="L1023">            builder = new ImmutableNode.Builder(1);</span>
<span class="fc" id="L1024">            builder.addChild(createNodeOnPath(it, newNodes));</span>
        }
        else
        {
<span class="fc" id="L1028">            builder = new ImmutableNode.Builder(newNodes.size());</span>
<span class="fc" id="L1029">            builder.addChildren(newNodes);</span>
        }
<span class="fc" id="L1031">        return builder.name(nodeName).create();</span>
    }

    /**
     * Initializes a transaction to clear the values of a property based on the
     * passed in collection of affected results.
     *
     * @param tx the transaction to be initialized
     * @param results a collection with results pointing to the nodes to be
     *        cleared
     * @return a flag whether there are elements to be cleared
     */
    private static boolean initializeClearTransaction(ModelTransaction tx,
            Collection&lt;QueryResult&lt;ImmutableNode&gt;&gt; results)
    {
<span class="fc bfc" id="L1046" title="All 2 branches covered.">        for (QueryResult&lt;ImmutableNode&gt; result : results)</span>
        {
<span class="fc bfc" id="L1048" title="All 2 branches covered.">            if (result.isAttributeResult())</span>
            {
<span class="fc" id="L1050">                tx.addRemoveAttributeOperation(result.getNode(),</span>
<span class="fc" id="L1051">                        result.getAttributeName());</span>
            }
            else
            {
<span class="fc" id="L1055">                tx.addClearNodeValueOperation(result.getNode());</span>
            }
<span class="fc" id="L1057">        }</span>

<span class="fc bfc" id="L1059" title="All 2 branches covered.">        return !results.isEmpty();</span>
    }

    /**
     * Initializes a transaction to change the values of some query results
     * based on the passed in map.
     *
     * @param tx the transaction to be initialized
     * @param changedValues the map defining the elements to be changed
     * @return a flag whether there are elements to be updated
     */
    private static boolean initializeUpdateTransaction(ModelTransaction tx,
            Map&lt;QueryResult&lt;ImmutableNode&gt;, Object&gt; changedValues)
    {
<span class="fc bfc" id="L1073" title="All 2 branches covered.">        for (Map.Entry&lt;QueryResult&lt;ImmutableNode&gt;, Object&gt; e : changedValues</span>
<span class="fc" id="L1074">                .entrySet())</span>
        {
<span class="fc bfc" id="L1076" title="All 2 branches covered.">            if (e.getKey().isAttributeResult())</span>
            {
<span class="fc" id="L1078">                tx.addAttributeOperation(e.getKey().getNode(), e.getKey()</span>
<span class="fc" id="L1079">                        .getAttributeName(), e.getValue());</span>
            }
            else
            {
<span class="fc" id="L1083">                tx.addChangeNodeValueOperation(e.getKey().getNode(),</span>
<span class="fc" id="L1084">                        e.getValue());</span>
            }
<span class="fc" id="L1086">        }</span>

<span class="fc bfc" id="L1088" title="All 2 branches covered.">        return !changedValues.isEmpty();</span>
    }

    /**
     * Determines the initial root node of this model. If a root node has been
     * provided, it is used. Otherwise, an empty dummy root node is created.
     *
     * @param providedRoot the passed in root node
     * @return the root node to be used
     */
    private static ImmutableNode initialRootNode(ImmutableNode providedRoot)
    {
<span class="fc bfc" id="L1100" title="All 2 branches covered.">        return (providedRoot != null) ? providedRoot</span>
<span class="fc" id="L1101">                : new ImmutableNode.Builder().create();</span>
    }

    /**
     * Determines the name of the root node for a merge operation. If a root
     * name is provided, it is used. Otherwise, if the current root node has no
     * name, the name of the node to be merged is used. A result of &lt;b&gt;null&lt;/b&gt;
     * means that no node name has to be set.
     *
     * @param rootNode the current root node
     * @param node the node to be merged with the root node
     * @param rootName the name of the resulting node
     * @return the new name of the root node
     */
    private static String determineRootName(ImmutableNode rootNode,
            ImmutableNode node, String rootName)
    {
<span class="fc bfc" id="L1118" title="All 2 branches covered.">        if (rootName != null)</span>
        {
<span class="fc" id="L1120">            return rootName;</span>
        }
<span class="fc bfc" id="L1122" title="All 2 branches covered.">        if (rootNode.getNodeName() == null)</span>
        {
<span class="fc" id="L1124">            return node.getNodeName();</span>
        }
<span class="fc" id="L1126">        return null;</span>
    }

    /**
     * Creates the mapping to parent nodes for the nodes structured represented
     * by the passed in root node. Each node is assigned its parent node. Here
     * an iterative algorithm is used rather than a recursive one to avoid stack
     * overflow for huge structures.
     *
     * @param root the root node of the structure
     * @return the parent node mapping
     */
    private Map&lt;ImmutableNode, ImmutableNode&gt; createParentMapping(
            ImmutableNode root)
    {
<span class="fc" id="L1141">        Map&lt;ImmutableNode, ImmutableNode&gt; parents =</span>
                new HashMap&lt;&gt;();
<span class="fc" id="L1143">        updateParentMapping(parents, root);</span>
<span class="fc" id="L1144">        return parents;</span>
    }

    /**
     * Performs a non-blocking, thread-safe update of this model based on a
     * transaction initialized by the passed in initializer. This method uses
     * the atomic reference for the model's current data to ensure that an
     * update was successful even if the model is concurrently accessed.
     *
     * @param txInit the {@code TransactionInitializer}
     * @param selector an optional {@code NodeSelector} defining the target node
     *        of the transaction
     * @param resolver the {@code NodeKeyResolver}
     */
    private void updateModel(TransactionInitializer txInit,
            NodeSelector selector, NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
        boolean done;

        do
        {
<span class="fc" id="L1165">            TreeData currentData = getTreeData();</span>
<span class="fc" id="L1166">            done =</span>
<span class="fc bfc" id="L1167" title="All 2 branches covered.">                    executeTransactionOnDetachedTrackedNode(txInit, selector,</span>
                            currentData, resolver)
<span class="fc bfc" id="L1169" title="All 2 branches covered.">                            || executeTransactionOnCurrentStructure(txInit,</span>
                                    selector, currentData, resolver);
<span class="fc bfc" id="L1171" title="All 2 branches covered.">        } while (!done);</span>
<span class="fc" id="L1172">    }</span>

    /**
     * Executes a transaction on the current data of this model. This method is
     * called if an operation is to be executed on the model's root node or a
     * tracked node which is not yet detached.
     *
     * @param txInit the {@code TransactionInitializer}
     * @param selector an optional {@code NodeSelector} defining the target node
     * @param currentData the current data of the model
     * @param resolver the {@code NodeKeyResolver}
     * @return a flag whether the operation has been completed successfully
     */
    private boolean executeTransactionOnCurrentStructure(
            TransactionInitializer txInit, NodeSelector selector,
            TreeData currentData, NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
        boolean done;
<span class="fc" id="L1190">        ModelTransaction tx =</span>
                new ModelTransaction(currentData, selector, resolver);
<span class="fc bfc" id="L1192" title="All 2 branches covered.">        if (!txInit.initTransaction(tx))</span>
        {
<span class="fc" id="L1194">            done = true;</span>
        }
        else
        {
<span class="fc" id="L1198">            TreeData newData = tx.execute();</span>
<span class="fc" id="L1199">            done = structure.compareAndSet(tx.getCurrentData(), newData);</span>
        }
<span class="fc" id="L1201">        return done;</span>
    }

    /**
     * Tries to execute a transaction on the model of a detached tracked node.
     * This method checks whether the target node of the transaction is a
     * tracked node and if this node is already detached. If this is the case,
     * the update operation is independent on this model and has to be executed
     * on the specific model for the detached node.
     *
     * @param txInit the {@code TransactionInitializer}
     * @param selector an optional {@code NodeSelector} defining the target node
     * @param currentData the current data of the model
     * @param resolver the {@code NodeKeyResolver} @return a flag whether the
     *        transaction could be executed
     * @throws ConfigurationRuntimeException if the selector cannot be resolved
     */
    private boolean executeTransactionOnDetachedTrackedNode(
            TransactionInitializer txInit, NodeSelector selector,
            TreeData currentData, NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc bfc" id="L1222" title="All 2 branches covered.">        if (selector != null)</span>
        {
<span class="fc" id="L1224">            InMemoryNodeModel detachedNodeModel =</span>
<span class="fc" id="L1225">                    currentData.getNodeTracker().getDetachedNodeModel(selector);</span>
<span class="fc bfc" id="L1226" title="All 2 branches covered.">            if (detachedNodeModel != null)</span>
            {
<span class="fc" id="L1228">                detachedNodeModel.updateModel(txInit, null, resolver);</span>
<span class="fc" id="L1229">                return true;</span>
            }
        }

<span class="fc" id="L1233">        return false;</span>
    }

    /**
     * Replaces a tracked node if it is already detached.
     *
     * @param currentData the current data of the model
     * @param selector the {@code NodeSelector} defining the tracked node
     * @param newNode the node replacing the tracked node
     * @return a flag whether the operation was successful
     */
    private boolean replaceDetachedTrackedNode(TreeData currentData,
            NodeSelector selector, ImmutableNode newNode)
    {
<span class="fc" id="L1247">        InMemoryNodeModel detachedNodeModel =</span>
<span class="fc" id="L1248">                currentData.getNodeTracker().getDetachedNodeModel(selector);</span>
<span class="fc bfc" id="L1249" title="All 2 branches covered.">        if (detachedNodeModel != null)</span>
        {
<span class="fc" id="L1251">            detachedNodeModel.setRootNode(newNode);</span>
<span class="fc" id="L1252">            return true;</span>
        }

<span class="fc" id="L1255">        return false;</span>
    }

    /**
     * Replaces an active tracked node. The node then becomes detached.
     *
     * @param currentData the current data of the model
     * @param selector the {@code NodeSelector} defining the tracked node
     * @param newNode the node replacing the tracked node
     * @return a flag whether the operation was successful
     */
    private boolean replaceActiveTrackedNode(TreeData currentData,
            NodeSelector selector, ImmutableNode newNode)
    {
<span class="fc" id="L1269">        NodeTracker newTracker =</span>
<span class="fc" id="L1270">                currentData.getNodeTracker().replaceAndDetachTrackedNode(</span>
                        selector, newNode);
<span class="fc" id="L1272">        return structure.compareAndSet(currentData,</span>
<span class="fc" id="L1273">                currentData.updateNodeTracker(newTracker));</span>
    }

    /**
     * Creates tracked node entries for the specified nodes and creates the
     * corresponding selectors.
     *
     * @param refSelectors the reference where to store the selectors
     * @param nodes the nodes to be tracked
     * @param current the current {@code TreeData} object
     * @param resolver the {@code NodeKeyResolver}
     * @return the updated {@code TreeData} object
     */
    private static TreeData createSelectorsForTrackedNodes(
            Mutable&lt;Collection&lt;NodeSelector&gt;&gt; refSelectors,
            List&lt;ImmutableNode&gt; nodes, TreeData current,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver)
    {
<span class="fc" id="L1291">        List&lt;NodeSelector&gt; selectors =</span>
<span class="fc" id="L1292">                new ArrayList&lt;&gt;(nodes.size());</span>
<span class="fc" id="L1293">        Map&lt;ImmutableNode, String&gt; cache = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1294" title="All 2 branches covered.">        for (ImmutableNode node : nodes)</span>
        {
<span class="fc" id="L1296">            selectors.add(new NodeSelector(resolver.nodeKey(node, cache,</span>
                    current)));
<span class="fc" id="L1298">        }</span>
<span class="fc" id="L1299">        refSelectors.setValue(selectors);</span>
<span class="fc" id="L1300">        NodeTracker newTracker =</span>
<span class="fc" id="L1301">                current.getNodeTracker().trackNodes(selectors, nodes);</span>
<span class="fc" id="L1302">        return current.updateNodeTracker(newTracker);</span>
    }

    /**
     * Adds a tracked node that has already been resolved to the specified data
     * object.
     *
     * @param current the current {@code TreeData} object
     * @param node the node in question
     * @param resolver the {@code NodeKeyResolver}
     * @param refSelector here the newly created {@code NodeSelector} is
     *        returned
     * @return the new {@code TreeData} instance
     */
    private static TreeData updateDataWithNewTrackedNode(TreeData current,
            ImmutableNode node, NodeKeyResolver&lt;ImmutableNode&gt; resolver,
            MutableObject&lt;NodeSelector&gt; refSelector)
    {
<span class="fc" id="L1320">        NodeSelector selector =</span>
<span class="fc" id="L1321">                new NodeSelector(resolver.nodeKey(node,</span>
                        new HashMap&lt;ImmutableNode, String&gt;(), current));
<span class="fc" id="L1323">        refSelector.setValue(selector);</span>
<span class="fc" id="L1324">        NodeTracker newTracker =</span>
<span class="fc" id="L1325">                current.getNodeTracker().trackNodes(</span>
<span class="fc" id="L1326">                        Collections.singleton(selector),</span>
<span class="fc" id="L1327">                        Collections.singleton(node));</span>
<span class="fc" id="L1328">        return current.updateNodeTracker(newTracker);</span>
    }

    /**
     * Creates a new data object with a tracked child node of the given parent
     * node. If such a child node already exists, it is used. Otherwise, a new
     * one is created.
     *
     * @param current the current {@code TreeData} object
     * @param parent the parent node
     * @param childName the name of the child node
     * @param resolver the {@code NodeKeyResolver}
     * @param refSelector here the newly created {@code NodeSelector} is
     *        returned
     * @return the new {@code TreeData} instance
     */
    private static TreeData createDataWithTrackedChildNode(TreeData current,
            ImmutableNode parent, String childName,
            NodeKeyResolver&lt;ImmutableNode&gt; resolver,
            MutableObject&lt;NodeSelector&gt; refSelector)
    {
        TreeData newData;
<span class="fc" id="L1350">        List&lt;ImmutableNode&gt; namedChildren =</span>
<span class="fc" id="L1351">                current.getChildren(parent, childName);</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">        if (!namedChildren.isEmpty())</span>
        {
<span class="fc" id="L1354">            newData =</span>
<span class="fc" id="L1355">                    updateDataWithNewTrackedNode(current, namedChildren.get(0),</span>
                            resolver, refSelector);
        }
        else
        {
<span class="fc" id="L1360">            ImmutableNode child =</span>
<span class="fc" id="L1361">                    new ImmutableNode.Builder().name(childName).create();</span>
<span class="fc" id="L1362">            ModelTransaction tx = new ModelTransaction(current, null, resolver);</span>
<span class="fc" id="L1363">            tx.addAddNodeOperation(parent, child);</span>
<span class="fc" id="L1364">            newData =</span>
<span class="fc" id="L1365">                    updateDataWithNewTrackedNode(tx.execute(), child, resolver,</span>
                            refSelector);
        }
<span class="fc" id="L1368">        return newData;</span>
    }

    /**
     * Checks whether the specified collection with values is not empty.
     *
     * @param values the collection with node values
     * @return &lt;b&gt;true&lt;/b&gt; if values are provided, &lt;b&gt;false&lt;/b&gt; otherwise
     */
    private static boolean valuesNotEmpty(Iterable&lt;?&gt; values)
    {
<span class="fc" id="L1379">        return values.iterator().hasNext();</span>
    }

    /**
     * Creates an exception referring to an invalid key for adding properties.
     * Such an exception is thrown when an operation tries to add something to
     * an attribute.
     *
     * @param key the invalid key causing this exception
     * @return the exception
     */
    private static RuntimeException attributeKeyException(String key)
    {
<span class="fc" id="L1392">        return new IllegalArgumentException(</span>
                &quot;New nodes cannot be added to an attribute key: &quot; + key);
    }

    /**
     * An interface used internally for handling concurrent updates. An
     * implementation has to populate the passed in {@code ModelTransaction}.
     * The transaction is then executed, and an atomic update of the model's
     * {@code TreeData} is attempted. If this fails - because another update
     * came across -, the whole operation has to be tried anew.
     */
    private interface TransactionInitializer
    {
        /**
         * Initializes the specified transaction for an update operation. The
         * return value indicates whether the transaction should be executed. A
         * result of &lt;b&gt;false&lt;/b&gt; means that the update is to be aborted (maybe
         * another update method was called).
         *
         * @param tx the transaction to be initialized
         * @return a flag whether the update should continue
         */
        boolean initTransaction(ModelTransaction tx);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>